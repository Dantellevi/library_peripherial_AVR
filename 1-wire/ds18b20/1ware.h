
#if PORT_W == 1 
	#define PORT PORTA
	#define PIN PINA
	#define DDR DDRA
	
#elif PORT_W == 2
	#define PORT PORTB
	#define PIN PINB
	#define DDR DDRB

#elif PORT_W == 3
	#define PORT PORTC
	#define PIN PINC
	#define DDR DDRC
	
#elif PORT_W == 4
	#define PORT PORTD
	#define PIN PIND
	#define DDR DDRD

#elif PORT_W == 5
	#define PORT PORTE
	#define PIN PINE
	#define DDR DDRE

#elif PORT_W == 6
	#define PORT PORTF
	#define PIN PINF	
	#define DDR DDRF

#elif PORT_W == 7
	#define PORT PORTG
	#define PIN PING
	#define DDR DDRG

#endif

#define OWIRE_0 DDR |= (1<<PIN_W)			// Прижимаем линию к GND
#define OWIRE_1 DDR &= ~(1<<PIN_W)			// Отпускаем линию и даем подтянуть к питанию через резистор

#include <avr/interrupt.h>
#include <util/delay.h>

unsigned char owire_init()					// Функция инициализации. Возвращает 1 если присктствует устройство на шине, иначе 0
{
	cli();									// Запрещаем прерывания на время работы функции, дабы те не вмешались во временные задержки. Можно убрать если не использовать прерывания
	unsigned char i;						// Переменная для цикла
	OWIRE_0;								// Прижимаем линию к GND
	_delay_us(480);							// Топчимся 480 мкс
	OWIRE_1;								// Отпускаем линию
	_delay_us(2);							// Тпчимся 2 мкс
	 
	for (i=0; i<100; i++)					// Ждём не менее 60 мкс до появления импульса присутствия. (Линия должна прижаться Слейвом к GND)
	{
		if (!(PIN & (1<<PIN_W)))			// Читаем уровень на линии. Если 0 то бежим в цикл ниже
		{
			while (!(PIN & (1<<PIN_W)));	// Если проишел импульс присутствия, ждём его окончания. То есть ждем 1
			sei();							// Разрешаем прерывания. Мы же их запрещали. Так же можно выкинуть от сюда
			return 1;						// Возвращаем 1 если хоть одно устройство присутствует на шине
		}
		_delay_us(1);						// Немного потупим
	}
	sei();									// Разрешаем прерывания. Это если устройств не обнаружено, то мы в тело ИФа не зайдем.
	return 0;								// Возвращаем 0, устройств на шине нэма.
}


void owire_write(unsigned char b)			// Функция для передачи байта в шину
{
	cli();									// Запрещаем прерывания. Чтоб не мешали.
	unsigned char temp, i;					// Создаем буферную переменную и переменную для цикла
	for(i=0; i<8; i++)						// Восемь раз выполняем код
	{
		temp=(b&0x01);						// В буфер пихаем значение передаваемого байта логически умноженного на 1. Короче вычленяем значение бита нулевого разряда.
		if(temp)							// Если этот бит равен 1 то пихаем 1 в шину. Делается это так
		{ 
			OWIRE_0;						// Сначала прижимаем линию к GND
			_delay_us(6);					// Затем удерживаем 6 мкс (Так рекомендует тех документация которай у меня есть по шине 1-wire)
			OWIRE_1;						// Теперь отпускаем линию, пусть резистор работает
			_delay_us(64);					// Выжидаем в таком состоянии 64 мкс.
		}
		else								// Если бит был равен 0
		{
			OWIRE_0;						// Прижимаем линию к GND
			_delay_us(60);					// Ждем 60 мкс
			OWIRE_1;						// Отпускаем линию
			_delay_us(10);					// Ждем 10 мкс
		}
		b>>=1;								// Двигаем вправо наш передоваемый байт на 1 разряд дабы передать следующий байт
	}
	sei();									// Разрешаем прерывания
}

unsigned char owire_read_bit()				// Функция чтения бита из шины. По сути эту функцию можно интегрировать в функцию чтения байта. Я ее создал для чтения уровня, но не использую
{
	cli();									// Запрещаем прерывания
	unsigned char bit;						// Переменная в которой будет хрониться	бит
	OWIRE_0;								// Прижимаем линию к GND
	_delay_us(2);							// Ждем 2 мкс
	OWIRE_1;								// Отпускаем линию
	_delay_us(5);							// Ждем 5 мкс
	bit = PIN & (1<<PIN_W);					// Читаем уровень на линии и записываем значение в переменную
	_delay_us(80);							// Ждем 80 мкс. Длинна передачи бита
	sei();									// Разрешаем прерывания
	return bit;								// Возвращаем значение бита
}


unsigned char owire_read()					// Функция чтения байта
{
	cli();									// Запрещаем прерывания
	unsigned byte = 0, i;					// Создаем переменные буфера(обязательно обнулить, а то запишется мусор) и для цикла
	for (i=0; i<8; i++)						// Условие цикла
	{
		byte >>= 1;							// Двигаем бит по нашему байту вправо
		if (owire_read_bit())				// Читаем бит. Вот здесь можно читать уровень, а битовую функцию выкинуть. Лишний код етит
		byte |= 0x80;						// Логическое или с нашим байтом. Если пришла 1, то запишем ее
	}
	sei();									// Разрешить прерывания
	return byte;							// Возвращаем принятый байт
}