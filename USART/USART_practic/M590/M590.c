#include "M590.h"

char buffer_response[128]={0};		//буффер для хранения ответов



//=====================Проход по приемному буфферу и его очистка===================
void Clear_bufferResponse(void)
{

	for (int i=0;i<128;i++)
	{
	buffer_response[i]=0;
	}
}
//==================================================================================



/*
char *glas(char *str1, char *str2)
{
	int i, end;
	putchar('\n');
	printf("Per: %s\n", str1);
	printf("Vtor: %s\n", str2);
	end = strlen(str1);
	for (i=0; i<end; i++)
	str1[i] = toupper(str1[i]);
	return str1;
}
*/


/*
========================Функция проверки присутствие модуля на линии USART=============================

Возращаемое значение:
char-возращает флаг  Connection-модуль подключен или ERROR-ошибка, отсутствует датчик

*/
char CheckModuleM590(void)
{	
	//unsigned char count_byte=0;
	for (int i=0;i<2;i++)		//цикл необходим т.к. модуль срабатывает только при повторной отправке команды
	{
		Usart_str_transmit("AT\r");		//команда на проверку модуля
		Usart_str_in(buffer_response,6);	//Принимает ответ из 6 байт(\r\nOK\r\n)или (\r\nERRO)
	}

	int compVal=strcmp(buffer_response,"\r\nOK\r\n");
	if (compVal==0)
	{
		//строки одинаковы(модуль прислал ОК)
		return CONNECTION;
	}
	else
	{
		return ERROR;
	}

}

//==============================================================



/*
==========================Функция отправки команды============================

	Принимаемые параметры:
		char*- принимает указатель на массив символов (определенная команда для модуля)
	Возращаемое значение:
		char*-возращает ответ от модуля в виде строки символов
		-------------------------------------------------------------------------------
		Использовать только для проверочных команд не установочных!!!!
*/
char *SendCommandM590(char *strCommand,char TypeCommand)
{
	//int byteCount;
	char buf[128]={0};
	strcpy(buf,strCommand);
	
	strcat(buf,"\r");
	UCSRB&=~(1<<RXEN);
	UCSRB|=(1<<TXEN);
	Usart_str_transmit(buf);
	UCSRB|=(1<<RXEN);
	UCSRB&=~(1<<TXEN);
	switch(TypeCommand)
	{
		case COM_ATE_ECHO:		//Запрос на работу в режиме эхо
		{
			
			Usart_str_in(buffer_response,6);
			
			break;
		}

		case COM_AT_CHECKVERSION:	//запрос на версию модуля
		{
			Usart_str_in(buffer_response,6);
			break;
		}

		case COM_AT_VERSION:		//версия прошивки
		{
			Usart_str_in(buffer_response,6);
			break;
		}

		case COM_STATUS:			//проверка статуса
		{
			Usart_str_in(buffer_response,15);
			break;
		}

		case COM_POWER:				//выключение/включение модуля
		{
			Usart_str_in(buffer_response,6);
			break;
		}
		default:
			UCSRB|=(1<<RXEN);
			UCSRB|=(1<<TXEN);
			return "Error";
	}

	UCSRB|=(1<<RXEN);
	UCSRB|=(1<<TXEN);
	return buffer_response;

	
}

//============================================================================================



/*
==================================Функция сохранение текущей конфигурации настроек в EEPROM память===
<значение>:
0 – сохранить настройки в  0-м профиле, параметр 0 можно не указывать;
1 – сохранить настройки в 1-м профиле
*/

char *SaveConfigEEPROM_M590(unsigned char val)
{
	//====================Передача команды=======================
	char buf[40]={0};
	strcat(buf,AT_SAVECONF);
	if (val==0)
	{
		strcat(buf,"0");
	}
	else if (val==1)
	{
		strcat(buf,"1");
	}
	strcat(buf,"\r");
	//-------------------------------
	UCSRB&=~(1<<RXEN);
	UCSRB|=(1<<TXEN);
	//-------------------------------
	Usart_str_transmit(buf);
	UCSRB|=(1<<RXEN);
	UCSRB&=~(1<<TXEN);
	//=========================Прием ответа==================================
	Clear_bufferResponse();		//Очищаем буффер для приема
	Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
	UCSRB|=(1<<RXEN);
	UCSRB|=(1<<TXEN);
	//=======================================================================
	return buffer_response;

}
//=====================================================================================================


/*
===================================Функция установки и проверки скорости работы модуля=======================

Принимаемые параметры:
		long int-скорость в бодах
		flagreq- флаг отвечающий за операции 1-установка скорости, 2- получение текущей скорости
*/

char *SetBuadM590(long int baud,char flagreq)
{
	char buff[60]={0};
	if (flagreq==FLAG_BAUD_SET)		//устанавливаем скорость
	{	
	//======================Отсылаем команду======================
		char str[40];
		itoa(baud,str,10);
		strcat(buff,str);
		strcat(buff,"\r");
		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		Usart_str_transmit(buff);
		//==========================Получаем ответ от модуля==============================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
	}
	else				//проверяем установленную скорость модуля
	{
	//=====================Посылаем команду на проверку скорости=======================
		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		Usart_str_transmit("AT+IPR?\r");
	//===============================Принимаем ответ===================================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,19);		//ожидаем принять ответ ввиде :\r\n+IPR: 9600\r\n\r\nOK\r\n(19 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
	}
}
//================================================================================================================


/*
============================Команда проверки регистрации модуля в сети==========================
	AT+CREG: <mode>
	<mode>:
	0 – выключить уведомление о регистрации в сети
	1 –  включить уведомление о регистрации в сети +CREG: <stat>
	2 – включить уведомление о регистрации в сети и информацию о местоположении<
	
	stat>:
	0 – не зарегистрирован, поиск сети не выполняется
	1 – зарегистрирован в домашней сети
	2 – регистрация отклонена
	3 – не зарегистрирован, выполняется поиск сети
	4 – неизвестно
	5 – зарегистрирован, зона роуминга
	//-------------------------------------------------------
	AT+CREG=1		Включить уведомление о регистрации в сети
	OK
	//---------------------------------------------------------
	AT+CREG?		Зарегистрирован в домашней сети
	+CREG: 0,1
	
	OK
	--------------------------------------------------------------
	Принимаемы параметры:
		flag-отвечает за установку либо за получения статуса
		mode-переменная отвечающая за команду на модуль
	Возращаемые параметры:
		*char- полученный ответ 
*/

char *CHeckRegeistrationM590(char flag,char mode)
{
	char buff[128]={0};
	if (flag==FLAG_STATUS_R_SET)	//установка статуса
	{
		//========================Передача команды на установление статуса========
		strcat(buff,AT_CREG_SET);
		strcat(buff,(char*)mode);
		strcat(buff,"\r");
		//===================Временно отключаем прием данных============================

		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		//=======================Передача команды===================
		Usart_str_transmit(buff);



		//==================Прием ответа================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
		//==============================================
	}
	else
	{
		
		//========================Передача команды на получение статуса========
		strcat(buff,AT_CREG_GET);
		strcat(buff,"\r");
		//===================Временно отключаем прием данных============================

		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		//=======================Передача команды===================
		Usart_str_transmit(buff);

		//==================Прием ответа================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,13);		//ожидаем принять ответ ввиде :\r\n+CREG: 0,1\r\n(13 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
		//==============================================

	}
}

//==========================================================================================


/*
=========================Команда настройки спящего режима============================
	
	Принимаемые параметры :
			char-флаг управления(разрешение/запрет) режимом сна
	Возращаемые параметры:
			char*-массив символов(ответ от модуля)
*/

char *SleepModeM590(char flagMode)
{
		char buffer[128]={0};
		//========================Передача команды на разрешение спящего режима========
		strcat(buffer,AT_SLEEP);
		strcat(buffer,(char*)flagMode);
		strcat(buffer,"\r");
			//===================Временно отключаем прием данных============================

		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
			//=======================Передача команды===================
		Usart_str_transmit(buffer);
			//===============================Получаем ответ==============================
			//==================Прием ответа================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;

				
}

//=========================================================================================

/*
===========================Функция настройки формата SMS-сообщения==============
	Описание	Команда настройки формата SMS сообщений
	Формат	AT+CMGF=<режим>
	Параметр	<режим>: 0 – PDU формат; 1 – текстовый формат
	Ответ	OK или ERROR
	Пример	AT+CMGF =1
	OK
	Примечание	Если сообщение отправляется в PDU формате, необходимо установить кодировку UCS2 (при использовании кириллических символов), для текстового формата кодировку GSM, либо UCS2
	
	В PDU формате, текст представлен в виде последовательности шестнадцатеричных чисел.
	-------------------------------------------------------------------------------------------------
	Принимаемые параметры :
			char -принимает флаг по управлению  форматом сообщения
			
	Возращаемые параметры:
			char*-массив символов(ответ от модуля)



*/

char *SettingSMSFormat(char flag)
{
	char buf[128]={0};
	if (flag==SMS_FORMAT_TEXT)		//текстовый формат(данные подаются ввиде 16-ых символов)
	{
		
		strcat(buf,flag);
		strcat(buf,"\r");
		//===================Временно отключаем прием данных============================

		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		//=======================Передача команды===================
		Usart_str_transmit(buf);
		//==================Прием ответа================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
	}
	else
	{
		strcat(buf,flag);
		strcat(buf,"\r");
		//===================Временно отключаем прием данных============================

		UCSRB&=~(1<<RXEN);
		UCSRB|=(1<<TXEN);
		//=======================Передача команды на PDU режим===================
		Usart_str_transmit(buf);
		//================================Посылка команды на кодировку===============

		//===========================================================================
		//==================Прием ответа================
		UCSRB|=(1<<RXEN);
		UCSRB&=~(1<<TXEN);
		Clear_bufferResponse();		//Очищаем буффер для приема
		Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
		UCSRB|=(1<<RXEN);
		UCSRB|=(1<<TXEN);
		return buffer_response;
	}

}

/*
=======================Функция кодировки текста в режиме PDU======================
char-параметр необязателен, он используется только при PDU режиме (кодировка текста)
варианты кодировки:
“GSM” – кодировка ASCII
“HEX” – кодировка шестнадцатеричными значениями
“IRA” – международный справочный алфавит
“PCCP437” – кодировка CP437 (IBM PC)
“8859-1” – кодовые страницы семейства ISO 8859
“UCS2” – кодировка Unicode (2 байта на символ)

*/

char *PDUEncoding(char Encoding)
{
	char buf[128]={0};
	strcat(buf,Encoding);
	strcat(buf,"\r");
	UCSRB&=~(1<<RXEN);
	UCSRB|=(1<<TXEN);
	//=======================Передача команды на PDU режим===================
	Usart_str_transmit(buf);
	//==================Прием ответа================
	UCSRB|=(1<<RXEN);
	UCSRB&=~(1<<TXEN);
	Clear_bufferResponse();		//Очищаем буффер для приема
	Usart_str_in(buffer_response,6);		//ожидаем принять ответ ввиде :\r\nOK\r\n(6 байт)
	UCSRB|=(1<<RXEN);
	UCSRB|=(1<<TXEN);
	return buffer_response;

}

//=================================================================================



/*
==================Команда чтения SMS-сообщения=========
		Принимаемые параметры :
				
				int -размер сообщения
			
		Возращаемые параметры:
		char*-ответ от модуля(сообщение + параметры сообщения)
*/


char *GetSMS_M590(int lengthSMS, char indexPhone)
{
	char buf[128]={0};
	strcat(buf,AT_SMS_RESSIEVE);
	strcat(buf,indexPhone);
	strcat(buf,"\r");
	UCSRB&=~(1<<RXEN);
	UCSRB|=(1<<TXEN);
	//=======================Передача команды на PDU режим===================
	Usart_str_transmit(buf);
	//==================Прием ответа================
	UCSRB|=(1<<RXEN);
	UCSRB&=~(1<<TXEN);
	Clear_bufferResponse();		//Очищаем буффер для приема
	Usart_str_in(buffer_response,lengthSMS+62);		//ожидаем принять ответ ввиде :+CMGR: <stat>,<oa>,<alpha>,<scts>\r\n<data>\r\nOK\r\n(datalength+62 байт)
	UCSRB|=(1<<RXEN);
	UCSRB|=(1<<TXEN);
	return buffer_response;

}


//========================================================================================




/*
====================================Команда отправки сообщения============================
			Принимаемые параметры :
			char*-передаваемое  сообщение
			char*-номер на который необходимо отправить сообщщение
			
			Возращаемые параметры:
			char*-ответ от модуля


*/

char *SendSMS_M590(char* messege,char* Number)
{
	
	char buf[128]={0};
	char Mbuf[100]={0};
	strcat(buf,AT_SEND_SMS);
	strcat(buf,Number);
	strcat(buf,"\r");
	UCSRB&=~(1<<RXEN);
	UCSRB|=(1<<TXEN);
	//=======================Передача команды на PDU режим===================
	Usart_str_transmit(buf);

	_delay_ms(10);			//ждем 10 мс и отправляем сообщение
	strcat(Mbuf,messege);
	strcat(Mbuf,0x1A);
	Usart_str_transmit(Mbuf);
	//==================Прием ответа================
	UCSRB|=(1<<RXEN);
	UCSRB&=~(1<<TXEN);
	Clear_bufferResponse();		//Очищаем буффер для приема
	Usart_str_in(buffer_response,15);		//ожидаем принять ответ ввиде :+CMGS: 2\r\n\r\nOK\r\n(15 байт)
	UCSRB|=(1<<RXEN);
	UCSRB|=(1<<TXEN);
	return buffer_response;

}









