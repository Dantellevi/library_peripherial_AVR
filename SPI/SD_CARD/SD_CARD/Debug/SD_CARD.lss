
SD_CARD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001bd8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008e  00800060  00001bd8  00001c6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  008000ee  008000ee  00001cfa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001cfa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001d2c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a0  00000000  00000000  00001d68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000039dc  00000000  00000000  00001f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000edd  00000000  00000000  000058e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001be4  00000000  00000000  000067c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000754  00000000  00000000  000083a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000781  00000000  00000000  00008afc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003492  00000000  00000000  0000927d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001d8  00000000  00000000  0000c70f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ed       	ldi	r30, 0xD8	; 216
      68:	fb e1       	ldi	r31, 0x1B	; 27
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 3e       	cpi	r26, 0xEE	; 238
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	20 e0       	ldi	r18, 0x00	; 0
      78:	ae ee       	ldi	r26, 0xEE	; 238
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3f       	cpi	r26, 0xF3	; 243
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 87 01 	call	0x30e	; 0x30e <main>
      8a:	0c 94 ea 0d 	jmp	0x1bd4	; 0x1bd4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <lcd_out>:
		str++;
	}
	
	lcd_gotoxy(0,0);

}
      92:	80 ff       	sbrs	r24, 0
      94:	02 c0       	rjmp	.+4      	; 0x9a <lcd_out+0x8>
      96:	94 9a       	sbi	0x12, 4	; 18
      98:	01 c0       	rjmp	.+2      	; 0x9c <lcd_out+0xa>
      9a:	94 98       	cbi	0x12, 4	; 18
      9c:	81 ff       	sbrs	r24, 1
      9e:	02 c0       	rjmp	.+4      	; 0xa4 <lcd_out+0x12>
      a0:	95 9a       	sbi	0x12, 5	; 18
      a2:	01 c0       	rjmp	.+2      	; 0xa6 <lcd_out+0x14>
      a4:	95 98       	cbi	0x12, 5	; 18
      a6:	82 ff       	sbrs	r24, 2
      a8:	02 c0       	rjmp	.+4      	; 0xae <lcd_out+0x1c>
      aa:	96 9a       	sbi	0x12, 6	; 18
      ac:	01 c0       	rjmp	.+2      	; 0xb0 <lcd_out+0x1e>
      ae:	96 98       	cbi	0x12, 6	; 18
      b0:	83 ff       	sbrs	r24, 3
      b2:	02 c0       	rjmp	.+4      	; 0xb8 <lcd_out+0x26>
      b4:	97 9a       	sbi	0x12, 7	; 18
      b6:	08 95       	ret
      b8:	97 98       	cbi	0x12, 7	; 18
      ba:	08 95       	ret

000000bc <lcd_com>:
      bc:	90 98       	cbi	0x12, 0	; 18
      be:	0e 94 49 00 	call	0x92	; 0x92 <lcd_out>
      c2:	92 9a       	sbi	0x12, 2	; 18
      c4:	92 98       	cbi	0x12, 2	; 18
      c6:	8f e3       	ldi	r24, 0x3F	; 63
      c8:	9f e1       	ldi	r25, 0x1F	; 31
      ca:	01 97       	sbiw	r24, 0x01	; 1
      cc:	f1 f7       	brne	.-4      	; 0xca <lcd_com+0xe>
      ce:	00 c0       	rjmp	.+0      	; 0xd0 <lcd_com+0x14>
      d0:	00 00       	nop
      d2:	08 95       	ret

000000d4 <lcd_init>:
      d4:	cf 93       	push	r28
      d6:	c8 2f       	mov	r28, r24
      d8:	88 9a       	sbi	0x11, 0	; 17
      da:	89 9a       	sbi	0x11, 1	; 17
      dc:	8a 9a       	sbi	0x11, 2	; 17
      de:	8c 9a       	sbi	0x11, 4	; 17
      e0:	8d 9a       	sbi	0x11, 5	; 17
      e2:	8e 9a       	sbi	0x11, 6	; 17
      e4:	8f 9a       	sbi	0x11, 7	; 17
      e6:	81 30       	cpi	r24, 0x01	; 1
      e8:	41 f0       	breq	.+16     	; 0xfa <lcd_init+0x26>
      ea:	28 f0       	brcs	.+10     	; 0xf6 <lcd_init+0x22>
      ec:	82 30       	cpi	r24, 0x02	; 2
      ee:	39 f0       	breq	.+14     	; 0xfe <lcd_init+0x2a>
      f0:	83 30       	cpi	r24, 0x03	; 3
      f2:	39 f0       	breq	.+14     	; 0x102 <lcd_init+0x2e>
      f4:	07 c0       	rjmp	.+14     	; 0x104 <lcd_init+0x30>
      f6:	cc e0       	ldi	r28, 0x0C	; 12
      f8:	05 c0       	rjmp	.+10     	; 0x104 <lcd_init+0x30>
      fa:	cd e0       	ldi	r28, 0x0D	; 13
      fc:	03 c0       	rjmp	.+6      	; 0x104 <lcd_init+0x30>
      fe:	ce e0       	ldi	r28, 0x0E	; 14
     100:	01 c0       	rjmp	.+2      	; 0x104 <lcd_init+0x30>
     102:	cf e0       	ldi	r28, 0x0F	; 15
     104:	8f e3       	ldi	r24, 0x3F	; 63
     106:	9c e9       	ldi	r25, 0x9C	; 156
     108:	01 97       	sbiw	r24, 0x01	; 1
     10a:	f1 f7       	brne	.-4      	; 0x108 <lcd_init+0x34>
     10c:	00 c0       	rjmp	.+0      	; 0x10e <lcd_init+0x3a>
     10e:	00 00       	nop
     110:	83 e0       	ldi	r24, 0x03	; 3
     112:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     116:	9a e6       	ldi	r25, 0x6A	; 106
     118:	9a 95       	dec	r25
     11a:	f1 f7       	brne	.-4      	; 0x118 <lcd_init+0x44>
     11c:	00 c0       	rjmp	.+0      	; 0x11e <lcd_init+0x4a>
     11e:	83 e0       	ldi	r24, 0x03	; 3
     120:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     124:	8a e6       	ldi	r24, 0x6A	; 106
     126:	8a 95       	dec	r24
     128:	f1 f7       	brne	.-4      	; 0x126 <lcd_init+0x52>
     12a:	00 c0       	rjmp	.+0      	; 0x12c <lcd_init+0x58>
     12c:	83 e0       	ldi	r24, 0x03	; 3
     12e:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     132:	9a e6       	ldi	r25, 0x6A	; 106
     134:	9a 95       	dec	r25
     136:	f1 f7       	brne	.-4      	; 0x134 <lcd_init+0x60>
     138:	00 c0       	rjmp	.+0      	; 0x13a <lcd_init+0x66>
     13a:	82 e0       	ldi	r24, 0x02	; 2
     13c:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     140:	8a e6       	ldi	r24, 0x6A	; 106
     142:	8a 95       	dec	r24
     144:	f1 f7       	brne	.-4      	; 0x142 <lcd_init+0x6e>
     146:	00 c0       	rjmp	.+0      	; 0x148 <lcd_init+0x74>
     148:	82 e0       	ldi	r24, 0x02	; 2
     14a:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     14e:	88 e0       	ldi	r24, 0x08	; 8
     150:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     154:	80 e0       	ldi	r24, 0x00	; 0
     156:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     15a:	88 e0       	ldi	r24, 0x08	; 8
     15c:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     160:	80 e0       	ldi	r24, 0x00	; 0
     162:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     166:	81 e0       	ldi	r24, 0x01	; 1
     168:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     172:	86 e0       	ldi	r24, 0x06	; 6
     174:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     178:	80 e0       	ldi	r24, 0x00	; 0
     17a:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     17e:	8c 2f       	mov	r24, r28
     180:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     184:	cf 91       	pop	r28
     186:	08 95       	ret

00000188 <lcd_char_out>:
     188:	cf 93       	push	r28
     18a:	c8 2f       	mov	r28, r24
     18c:	90 9a       	sbi	0x12, 0	; 18
     18e:	82 95       	swap	r24
     190:	8f 70       	andi	r24, 0x0F	; 15
     192:	0e 94 49 00 	call	0x92	; 0x92 <lcd_out>
     196:	92 9a       	sbi	0x12, 2	; 18
     198:	92 98       	cbi	0x12, 2	; 18
     19a:	8c 2f       	mov	r24, r28
     19c:	8f 70       	andi	r24, 0x0F	; 15
     19e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_out>
     1a2:	92 9a       	sbi	0x12, 2	; 18
     1a4:	92 98       	cbi	0x12, 2	; 18
     1a6:	8f e3       	ldi	r24, 0x3F	; 63
     1a8:	9f e1       	ldi	r25, 0x1F	; 31
     1aa:	01 97       	sbiw	r24, 0x01	; 1
     1ac:	f1 f7       	brne	.-4      	; 0x1aa <lcd_char_out+0x22>
     1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <lcd_char_out+0x28>
     1b0:	00 00       	nop
     1b2:	cf 91       	pop	r28
     1b4:	08 95       	ret

000001b6 <lcd_str_out>:
     1b6:	cf 93       	push	r28
     1b8:	df 93       	push	r29
     1ba:	ec 01       	movw	r28, r24
     1bc:	88 81       	ld	r24, Y
     1be:	88 23       	and	r24, r24
     1c0:	31 f0       	breq	.+12     	; 0x1ce <lcd_str_out+0x18>
     1c2:	21 96       	adiw	r28, 0x01	; 1
     1c4:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_char_out>
     1c8:	89 91       	ld	r24, Y+
     1ca:	81 11       	cpse	r24, r1
     1cc:	fb cf       	rjmp	.-10     	; 0x1c4 <lcd_str_out+0xe>
     1ce:	df 91       	pop	r29
     1d0:	cf 91       	pop	r28
     1d2:	08 95       	ret

000001d4 <lcd_gotoxy>:
     1d4:	cf 93       	push	r28
     1d6:	88 32       	cpi	r24, 0x28	; 40
     1d8:	08 f0       	brcs	.+2      	; 0x1dc <lcd_gotoxy+0x8>
     1da:	87 e2       	ldi	r24, 0x27	; 39
     1dc:	90 98       	cbi	0x12, 0	; 18
     1de:	64 30       	cpi	r22, 0x04	; 4
     1e0:	08 f0       	brcs	.+2      	; 0x1e4 <lcd_gotoxy+0x10>
     1e2:	63 e0       	ldi	r22, 0x03	; 3
     1e4:	61 30       	cpi	r22, 0x01	; 1
     1e6:	91 f0       	breq	.+36     	; 0x20c <lcd_gotoxy+0x38>
     1e8:	28 f0       	brcs	.+10     	; 0x1f4 <lcd_gotoxy+0x20>
     1ea:	62 30       	cpi	r22, 0x02	; 2
     1ec:	d9 f0       	breq	.+54     	; 0x224 <lcd_gotoxy+0x50>
     1ee:	63 30       	cpi	r22, 0x03	; 3
     1f0:	29 f1       	breq	.+74     	; 0x23c <lcd_gotoxy+0x68>
     1f2:	2f c0       	rjmp	.+94     	; 0x252 <lcd_gotoxy+0x7e>
     1f4:	c0 e8       	ldi	r28, 0x80	; 128
     1f6:	c8 0f       	add	r28, r24
     1f8:	8c 2f       	mov	r24, r28
     1fa:	82 95       	swap	r24
     1fc:	8f 70       	andi	r24, 0x0F	; 15
     1fe:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     202:	8c 2f       	mov	r24, r28
     204:	8f 70       	andi	r24, 0x0F	; 15
     206:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     20a:	23 c0       	rjmp	.+70     	; 0x252 <lcd_gotoxy+0x7e>
     20c:	c0 ec       	ldi	r28, 0xC0	; 192
     20e:	c8 0f       	add	r28, r24
     210:	8c 2f       	mov	r24, r28
     212:	82 95       	swap	r24
     214:	8f 70       	andi	r24, 0x0F	; 15
     216:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     21a:	8c 2f       	mov	r24, r28
     21c:	8f 70       	andi	r24, 0x0F	; 15
     21e:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     222:	17 c0       	rjmp	.+46     	; 0x252 <lcd_gotoxy+0x7e>
     224:	c4 e9       	ldi	r28, 0x94	; 148
     226:	c8 0f       	add	r28, r24
     228:	8c 2f       	mov	r24, r28
     22a:	82 95       	swap	r24
     22c:	8f 70       	andi	r24, 0x0F	; 15
     22e:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     232:	8c 2f       	mov	r24, r28
     234:	8f 70       	andi	r24, 0x0F	; 15
     236:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     23a:	0b c0       	rjmp	.+22     	; 0x252 <lcd_gotoxy+0x7e>
     23c:	c4 ed       	ldi	r28, 0xD4	; 212
     23e:	c8 0f       	add	r28, r24
     240:	8c 2f       	mov	r24, r28
     242:	82 95       	swap	r24
     244:	8f 70       	andi	r24, 0x0F	; 15
     246:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     24a:	8c 2f       	mov	r24, r28
     24c:	8f 70       	andi	r24, 0x0F	; 15
     24e:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     252:	cf 91       	pop	r28
     254:	08 95       	ret

00000256 <lcd_printStringXY>:
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	ec 01       	movw	r28, r24
     25c:	86 2f       	mov	r24, r22
     25e:	64 2f       	mov	r22, r20
     260:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
     264:	ce 01       	movw	r24, r28
     266:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     26a:	df 91       	pop	r29
     26c:	cf 91       	pop	r28
     26e:	08 95       	ret

00000270 <lcd_clear>:
     270:	80 e0       	ldi	r24, 0x00	; 0
     272:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     27c:	08 95       	ret

0000027e <LCD_PrintLongStrring>:


void LCD_PrintLongStrring(char str1[])
{
     27e:	af 92       	push	r10
     280:	bf 92       	push	r11
     282:	cf 92       	push	r12
     284:	df 92       	push	r13
     286:	ef 92       	push	r14
     288:	ff 92       	push	r15
     28a:	0f 93       	push	r16
     28c:	1f 93       	push	r17
     28e:	cf 93       	push	r28
     290:	df 93       	push	r29
     292:	6c 01       	movw	r12, r24
	unsigned char n;
	lcd_com(0x80);//1 строка
     294:	80 e8       	ldi	r24, 0x80	; 128
     296:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
     29a:	86 01       	movw	r16, r12
     29c:	e6 01       	movw	r28, r12
     29e:	64 96       	adiw	r28, 0x14	; 20
	for(n=0;n<=19;n++)
	lcd_char_out(str1[n]);
     2a0:	f8 01       	movw	r30, r16
     2a2:	81 91       	ld	r24, Z+
     2a4:	8f 01       	movw	r16, r30
     2a6:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_char_out>

void LCD_PrintLongStrring(char str1[])
{
	unsigned char n;
	lcd_com(0x80);//1 строка
	for(n=0;n<=19;n++)
     2aa:	0c 17       	cp	r16, r28
     2ac:	1d 07       	cpc	r17, r29
     2ae:	c1 f7       	brne	.-16     	; 0x2a0 <LCD_PrintLongStrring+0x22>
     2b0:	56 01       	movw	r10, r12
     2b2:	f8 e2       	ldi	r31, 0x28	; 40
     2b4:	af 0e       	add	r10, r31
     2b6:	b1 1c       	adc	r11, r1
     2b8:	86 01       	movw	r16, r12
     2ba:	04 5c       	subi	r16, 0xC4	; 196
     2bc:	1f 4f       	sbci	r17, 0xFF	; 255
     2be:	75 01       	movw	r14, r10
	lcd_char_out(str1[n]);
	for(n=40;n<=59;n++)//на 3ю строку перейдём автоматически в силу организации DDRAM дисплея
	lcd_char_out(str1[n]);
     2c0:	f7 01       	movw	r30, r14
     2c2:	81 91       	ld	r24, Z+
     2c4:	7f 01       	movw	r14, r30
     2c6:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_char_out>
{
	unsigned char n;
	lcd_com(0x80);//1 строка
	for(n=0;n<=19;n++)
	lcd_char_out(str1[n]);
	for(n=40;n<=59;n++)//на 3ю строку перейдём автоматически в силу организации DDRAM дисплея
     2ca:	e0 16       	cp	r14, r16
     2cc:	f1 06       	cpc	r15, r17
     2ce:	c1 f7       	brne	.-16     	; 0x2c0 <LCD_PrintLongStrring+0x42>
	lcd_char_out(str1[n]);
	lcd_com(0xC0);//2 строка
     2d0:	80 ec       	ldi	r24, 0xC0	; 192
     2d2:	0e 94 5e 00 	call	0xbc	; 0xbc <lcd_com>
	for(n=20;n<=39;n++)
	lcd_char_out(str1[n]);
     2d6:	89 91       	ld	r24, Y+
     2d8:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_char_out>
	for(n=0;n<=19;n++)
	lcd_char_out(str1[n]);
	for(n=40;n<=59;n++)//на 3ю строку перейдём автоматически в силу организации DDRAM дисплея
	lcd_char_out(str1[n]);
	lcd_com(0xC0);//2 строка
	for(n=20;n<=39;n++)
     2dc:	ac 16       	cp	r10, r28
     2de:	bd 06       	cpc	r11, r29
     2e0:	d1 f7       	brne	.-12     	; 0x2d6 <LCD_PrintLongStrring+0x58>
     2e2:	e6 01       	movw	r28, r12
     2e4:	c0 5b       	subi	r28, 0xB0	; 176
     2e6:	df 4f       	sbci	r29, 0xFF	; 255
	lcd_char_out(str1[n]);
	for(n=60;n<=79;n++)//на 4ю строку перейдём автоматически в силу организации DDRAM дисплея
	lcd_char_out(str1[n]);
     2e8:	f8 01       	movw	r30, r16
     2ea:	81 91       	ld	r24, Z+
     2ec:	8f 01       	movw	r16, r30
     2ee:	0e 94 c4 00 	call	0x188	; 0x188 <lcd_char_out>
	for(n=40;n<=59;n++)//на 3ю строку перейдём автоматически в силу организации DDRAM дисплея
	lcd_char_out(str1[n]);
	lcd_com(0xC0);//2 строка
	for(n=20;n<=39;n++)
	lcd_char_out(str1[n]);
	for(n=60;n<=79;n++)//на 4ю строку перейдём автоматически в силу организации DDRAM дисплея
     2f2:	0c 17       	cp	r16, r28
     2f4:	1d 07       	cpc	r17, r29
     2f6:	c1 f7       	brne	.-16     	; 0x2e8 <LCD_PrintLongStrring+0x6a>
	lcd_char_out(str1[n]);



}
     2f8:	df 91       	pop	r29
     2fa:	cf 91       	pop	r28
     2fc:	1f 91       	pop	r17
     2fe:	0f 91       	pop	r16
     300:	ff 90       	pop	r15
     302:	ef 90       	pop	r14
     304:	df 90       	pop	r13
     306:	cf 90       	pop	r12
     308:	bf 90       	pop	r11
     30a:	af 90       	pop	r10
     30c:	08 95       	ret

0000030e <main>:




int main(void)
{
     30e:	cf 93       	push	r28
     310:	df 93       	push	r29
     312:	cd b7       	in	r28, 0x3d	; 61
     314:	de b7       	in	r29, 0x3e	; 62
     316:	ce 52       	subi	r28, 0x2E	; 46
     318:	d2 40       	sbci	r29, 0x02	; 2
     31a:	0f b6       	in	r0, 0x3f	; 63
     31c:	f8 94       	cli
     31e:	de bf       	out	0x3e, r29	; 62
     320:	0f be       	out	0x3f, r0	; 63
     322:	cd bf       	out	0x3d, r28	; 61
	lcd_init(0);
     324:	80 e0       	ldi	r24, 0x00	; 0
     326:	0e 94 6a 00 	call	0xd4	; 0xd4 <lcd_init>
	port_ini();
     32a:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <port_ini>
   //char str[10];
   FATFS fs; //FatFs объект
   FRESULT res; //Результат выполнения
   WORD s1;
   //char buffer[512] ="Selection of RAM is set by the previous address set instruction. If the address set instruction of RAM is not performed before this instruction, the data that has been read first is invalid, as the direction of AC is not yet determined. If RAM data is read several times without RAM address instructions set before, read operation, the correct RAM data can be obtained from the second. But the first data would be incorrect, as there is no time margin to transfer RAM data. In case of DDRAM read operation The..."; //Буфер данных для записи/чтения
    char buffer2[512] ={}; //Буфер данных для чтения
     32e:	fe 01       	movw	r30, r28
     330:	bf 96       	adiw	r30, 0x2f	; 47
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	92 e0       	ldi	r25, 0x02	; 2
     336:	df 01       	movw	r26, r30
     338:	9c 01       	movw	r18, r24
     33a:	1d 92       	st	X+, r1
     33c:	21 50       	subi	r18, 0x01	; 1
     33e:	30 40       	sbci	r19, 0x00	; 0
     340:	e1 f7       	brne	.-8      	; 0x33a <main+0x2c>
	//LCD_PrintLongStrring(buffer2+i*20);
	//_delay_ms(1000);
   //}
  //------------------------------------------------------------------------------------------------------------
  //-------------------------^-------Чтение из файла--------------------------------------------------
  lcd_clear();
     342:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
  asm("nop");
     346:	00 00       	nop
  res=pf_mount(&fs); //Монтируем FAT
     348:	ce 01       	movw	r24, r28
     34a:	01 96       	adiw	r24, 0x01	; 1
     34c:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <pf_mount>
  //sprintf(str,"%d",res);
  //lcd_printStringXY(str,0,0);
  if(res==FR_OK) lcd_printStringXY("Done",0,0);
     350:	81 11       	cpse	r24, r1
     352:	07 c0       	rjmp	.+14     	; 0x362 <main+0x54>
     354:	40 e0       	ldi	r20, 0x00	; 0
     356:	60 e0       	ldi	r22, 0x00	; 0
     358:	80 e6       	ldi	r24, 0x60	; 96
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     360:	06 c0       	rjmp	.+12     	; 0x36e <main+0x60>
  else lcd_printStringXY("Error",0,0);
     362:	40 e0       	ldi	r20, 0x00	; 0
     364:	60 e0       	ldi	r22, 0x00	; 0
     366:	85 e6       	ldi	r24, 0x65	; 101
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     36e:	3f ef       	ldi	r19, 0xFF	; 255
     370:	89 e6       	ldi	r24, 0x69	; 105
     372:	98 e1       	ldi	r25, 0x18	; 24
     374:	31 50       	subi	r19, 0x01	; 1
     376:	80 40       	sbci	r24, 0x00	; 0
     378:	90 40       	sbci	r25, 0x00	; 0
     37a:	e1 f7       	brne	.-8      	; 0x374 <main+0x66>
     37c:	00 c0       	rjmp	.+0      	; 0x37e <main+0x70>
     37e:	00 00       	nop
  _delay_ms(1000);
  lcd_printStringXY("Open file:",0,3);
     380:	43 e0       	ldi	r20, 0x03	; 3
     382:	60 e0       	ldi	r22, 0x00	; 0
     384:	8b e6       	ldi	r24, 0x6B	; 107
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
  res=pf_open("1.txt");//Попытка открыть файл 1.txt
     38c:	86 e7       	ldi	r24, 0x76	; 118
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	0e 94 1e 0a 	call	0x143c	; 0x143c <pf_open>
  if(res==FR_OK)
     394:	81 11       	cpse	r24, r1
     396:	07 c0       	rjmp	.+14     	; 0x3a6 <main+0x98>
  {
	lcd_printStringXY("Done",13,3);
     398:	43 e0       	ldi	r20, 0x03	; 3
     39a:	6d e0       	ldi	r22, 0x0D	; 13
     39c:	80 e6       	ldi	r24, 0x60	; 96
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     3a4:	06 c0       	rjmp	.+12     	; 0x3b2 <main+0xa4>
  }
  else lcd_printStringXY("Error",13,3);
     3a6:	43 e0       	ldi	r20, 0x03	; 3
     3a8:	6d e0       	ldi	r22, 0x0D	; 13
     3aa:	85 e6       	ldi	r24, 0x65	; 101
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     3b2:	af ef       	ldi	r26, 0xFF	; 255
     3b4:	b3 ed       	ldi	r27, 0xD3	; 211
     3b6:	20 e3       	ldi	r18, 0x30	; 48
     3b8:	a1 50       	subi	r26, 0x01	; 1
     3ba:	b0 40       	sbci	r27, 0x00	; 0
     3bc:	20 40       	sbci	r18, 0x00	; 0
     3be:	e1 f7       	brne	.-8      	; 0x3b8 <main+0xaa>
     3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <main+0xb4>
     3c2:	00 00       	nop
  _delay_ms(2000);
  lcd_printStringXY("Move pointer",0,2);
     3c4:	42 e0       	ldi	r20, 0x02	; 2
     3c6:	60 e0       	ldi	r22, 0x00	; 0
     3c8:	8c e7       	ldi	r24, 0x7C	; 124
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
  res=pf_lseek(0); //Установим курсор чтения на 0 в 1\.txt
     3d0:	60 e0       	ldi	r22, 0x00	; 0
     3d2:	70 e0       	ldi	r23, 0x00	; 0
     3d4:	cb 01       	movw	r24, r22
     3d6:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pf_lseek>
   if(res==FR_OK)
     3da:	81 11       	cpse	r24, r1
     3dc:	07 c0       	rjmp	.+14     	; 0x3ec <main+0xde>
   {
	   lcd_printStringXY("Done",13,3);
     3de:	43 e0       	ldi	r20, 0x03	; 3
     3e0:	6d e0       	ldi	r22, 0x0D	; 13
     3e2:	80 e6       	ldi	r24, 0x60	; 96
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     3ea:	06 c0       	rjmp	.+12     	; 0x3f8 <main+0xea>
   }
   else lcd_printStringXY("Error",13,3); 
     3ec:	43 e0       	ldi	r20, 0x03	; 3
     3ee:	6d e0       	ldi	r22, 0x0D	; 13
     3f0:	85 e6       	ldi	r24, 0x65	; 101
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     3f8:	3f ef       	ldi	r19, 0xFF	; 255
     3fa:	83 ed       	ldi	r24, 0xD3	; 211
     3fc:	90 e3       	ldi	r25, 0x30	; 48
     3fe:	31 50       	subi	r19, 0x01	; 1
     400:	80 40       	sbci	r24, 0x00	; 0
     402:	90 40       	sbci	r25, 0x00	; 0
     404:	e1 f7       	brne	.-8      	; 0x3fe <main+0xf0>
     406:	00 c0       	rjmp	.+0      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     408:	00 00       	nop
   _delay_ms(2000);
   lcd_printStringXY("Read File:",0,3);
     40a:	43 e0       	ldi	r20, 0x03	; 3
     40c:	60 e0       	ldi	r22, 0x00	; 0
     40e:	89 e8       	ldi	r24, 0x89	; 137
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
   res=pf_read(buffer2,128,&s1);
     416:	ae 01       	movw	r20, r28
     418:	43 5d       	subi	r20, 0xD3	; 211
     41a:	5f 4f       	sbci	r21, 0xFF	; 255
     41c:	60 e8       	ldi	r22, 0x80	; 128
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	ce 01       	movw	r24, r28
     422:	8f 96       	adiw	r24, 0x2f	; 47
     424:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pf_read>
   if(res==FR_OK)
     428:	81 11       	cpse	r24, r1
     42a:	07 c0       	rjmp	.+14     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
   {
	   lcd_printStringXY("Done",13,3);
     42c:	43 e0       	ldi	r20, 0x03	; 3
     42e:	6d e0       	ldi	r22, 0x0D	; 13
     430:	80 e6       	ldi	r24, 0x60	; 96
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     438:	06 c0       	rjmp	.+12     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
   }
   else lcd_printStringXY("Error",13,3);
     43a:	43 e0       	ldi	r20, 0x03	; 3
     43c:	6d e0       	ldi	r22, 0x0D	; 13
     43e:	85 e6       	ldi	r24, 0x65	; 101
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     446:	af ef       	ldi	r26, 0xFF	; 255
     448:	b3 ed       	ldi	r27, 0xD3	; 211
     44a:	20 e3       	ldi	r18, 0x30	; 48
     44c:	a1 50       	subi	r26, 0x01	; 1
     44e:	b0 40       	sbci	r27, 0x00	; 0
     450:	20 40       	sbci	r18, 0x00	; 0
     452:	e1 f7       	brne	.-8      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     454:	00 c0       	rjmp	.+0      	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
     456:	00 00       	nop
   _delay_ms(2000);
   lcd_clear();
     458:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
   lcd_gotoxy(0,0);
     45c:	60 e0       	ldi	r22, 0x00	; 0
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   LCD_PrintLongStrring(buffer2);
     464:	ce 01       	movw	r24, r28
     466:	8f 96       	adiw	r24, 0x2f	; 47
     468:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_PrintLongStrring>
   lcd_gotoxy(0,1);
     46c:	61 e0       	ldi	r22, 0x01	; 1
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
     474:	3f ef       	ldi	r19, 0xFF	; 255
     476:	83 ed       	ldi	r24, 0xD3	; 211
     478:	90 e3       	ldi	r25, 0x30	; 48
     47a:	31 50       	subi	r19, 0x01	; 1
     47c:	80 40       	sbci	r24, 0x00	; 0
     47e:	90 40       	sbci	r25, 0x00	; 0
     480:	e1 f7       	brne	.-8      	; 0x47a <__stack+0x1b>
     482:	00 c0       	rjmp	.+0      	; 0x484 <__stack+0x25>
     484:	00 00       	nop
   _delay_ms(2000);
   lcd_clear();
     486:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
   //--------------------------------------------------------------------------------------------------------------
   lcd_str_out("Unmout SD....");
     48a:	84 e9       	ldi	r24, 0x94	; 148
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_mount(0x00);//демонтируем файловую систему
     492:	80 e0       	ldi	r24, 0x00	; 0
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <pf_mount>
   if (res==FR_OK)
     49a:	81 11       	cpse	r24, r1
     49c:	05 c0       	rjmp	.+10     	; 0x4a8 <__stack+0x49>
   {
	lcd_str_out("Done");
     49e:	80 e6       	ldi	r24, 0x60	; 96
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     4a6:	04 c0       	rjmp	.+8      	; 0x4b0 <__stack+0x51>
   }
   else
   {
	lcd_str_out("Error");
     4a8:	85 e6       	ldi	r24, 0x65	; 101
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     4b0:	af ef       	ldi	r26, 0xFF	; 255
     4b2:	b9 e6       	ldi	r27, 0x69	; 105
     4b4:	28 e1       	ldi	r18, 0x18	; 24
     4b6:	a1 50       	subi	r26, 0x01	; 1
     4b8:	b0 40       	sbci	r27, 0x00	; 0
     4ba:	20 40       	sbci	r18, 0x00	; 0
     4bc:	e1 f7       	brne	.-8      	; 0x4b6 <__stack+0x57>
     4be:	00 c0       	rjmp	.+0      	; 0x4c0 <__stack+0x61>
     4c0:	00 00       	nop

   _delay_ms(1000);
   //-----------------------


   lcd_gotoxy(0,2);
     4c2:	62 e0       	ldi	r22, 0x02	; 2
     4c4:	80 e0       	ldi	r24, 0x00	; 0
     4c6:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   lcd_str_out("Mout SD");
     4ca:	82 ea       	ldi	r24, 0xA2	; 162
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_mount(&fs);	//монтируем систему
     4d2:	ce 01       	movw	r24, r28
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <pf_mount>
   if (res==FR_OK)
     4da:	81 11       	cpse	r24, r1
     4dc:	05 c0       	rjmp	.+10     	; 0x4e8 <__stack+0x89>
   {
	   lcd_str_out("Done");
     4de:	80 e6       	ldi	r24, 0x60	; 96
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__stack+0x91>
   }
   else
   {
	   lcd_str_out("Error");
     4e8:	85 e6       	ldi	r24, 0x65	; 101
     4ea:	90 e0       	ldi	r25, 0x00	; 0
     4ec:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     4f0:	3f ef       	ldi	r19, 0xFF	; 255
     4f2:	89 e6       	ldi	r24, 0x69	; 105
     4f4:	98 e1       	ldi	r25, 0x18	; 24
     4f6:	31 50       	subi	r19, 0x01	; 1
     4f8:	80 40       	sbci	r24, 0x00	; 0
     4fa:	90 40       	sbci	r25, 0x00	; 0
     4fc:	e1 f7       	brne	.-8      	; 0x4f6 <__stack+0x97>
     4fe:	00 c0       	rjmp	.+0      	; 0x500 <__stack+0xa1>
     500:	00 00       	nop
   }
   _delay_ms(1000);
   //------------------------
   lcd_gotoxy(0,3);
     502:	63 e0       	ldi	r22, 0x03	; 3
     504:	80 e0       	ldi	r24, 0x00	; 0
     506:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   lcd_str_out("Open File...");//открываем файл для записи
     50a:	8a ea       	ldi	r24, 0xAA	; 170
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_open("1.txt");//Попытка открыть файл 1.txt
     512:	86 e7       	ldi	r24, 0x76	; 118
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	0e 94 1e 0a 	call	0x143c	; 0x143c <pf_open>
   if (res==FR_OK)
     51a:	81 11       	cpse	r24, r1
     51c:	05 c0       	rjmp	.+10     	; 0x528 <__stack+0xc9>
   {
	   lcd_str_out("Done");
     51e:	80 e6       	ldi	r24, 0x60	; 96
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     526:	04 c0       	rjmp	.+8      	; 0x530 <__stack+0xd1>
   }
   else
   {
	   lcd_str_out("Error");
     528:	85 e6       	ldi	r24, 0x65	; 101
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     530:	af ef       	ldi	r26, 0xFF	; 255
     532:	b9 e6       	ldi	r27, 0x69	; 105
     534:	28 e1       	ldi	r18, 0x18	; 24
     536:	a1 50       	subi	r26, 0x01	; 1
     538:	b0 40       	sbci	r27, 0x00	; 0
     53a:	20 40       	sbci	r18, 0x00	; 0
     53c:	e1 f7       	brne	.-8      	; 0x536 <__stack+0xd7>
     53e:	00 c0       	rjmp	.+0      	; 0x540 <__stack+0xe1>
     540:	00 00       	nop
   }
   _delay_ms(1000);
   //---------------------

   lcd_gotoxy(0,1);
     542:	61 e0       	ldi	r22, 0x01	; 1
     544:	80 e0       	ldi	r24, 0x00	; 0
     546:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   lcd_str_out("Move pointer..");
     54a:	87 eb       	ldi	r24, 0xB7	; 183
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_lseek(0);	//устанавливаем курсор чтения на 0 в 1.txt
     552:	60 e0       	ldi	r22, 0x00	; 0
     554:	70 e0       	ldi	r23, 0x00	; 0
     556:	cb 01       	movw	r24, r22
     558:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <pf_lseek>
   if (res==FR_OK)
     55c:	81 11       	cpse	r24, r1
     55e:	05 c0       	rjmp	.+10     	; 0x56a <__stack+0x10b>
   {
	   lcd_str_out("Done");
     560:	80 e6       	ldi	r24, 0x60	; 96
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     568:	04 c0       	rjmp	.+8      	; 0x572 <__stack+0x113>
   }
   else
   {
	   lcd_str_out("Error");
     56a:	85 e6       	ldi	r24, 0x65	; 101
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   }
   //---------------------------------------

   lcd_printStringXY("Read File:",0,3);
     572:	43 e0       	ldi	r20, 0x03	; 3
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	89 e8       	ldi	r24, 0x89	; 137
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
   res=pf_read(buffer2,128,&s1);
     57e:	ae 01       	movw	r20, r28
     580:	43 5d       	subi	r20, 0xD3	; 211
     582:	5f 4f       	sbci	r21, 0xFF	; 255
     584:	60 e8       	ldi	r22, 0x80	; 128
     586:	70 e0       	ldi	r23, 0x00	; 0
     588:	ce 01       	movw	r24, r28
     58a:	8f 96       	adiw	r24, 0x2f	; 47
     58c:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pf_read>
   if(res==FR_OK)
     590:	81 11       	cpse	r24, r1
     592:	07 c0       	rjmp	.+14     	; 0x5a2 <__stack+0x143>
   {
	   lcd_printStringXY("Done",13,3);
     594:	43 e0       	ldi	r20, 0x03	; 3
     596:	6d e0       	ldi	r22, 0x0D	; 13
     598:	80 e6       	ldi	r24, 0x60	; 96
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     5a0:	06 c0       	rjmp	.+12     	; 0x5ae <__stack+0x14f>
   }
   else lcd_printStringXY("Error",13,3);
     5a2:	43 e0       	ldi	r20, 0x03	; 3
     5a4:	6d e0       	ldi	r22, 0x0D	; 13
     5a6:	85 e6       	ldi	r24, 0x65	; 101
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     5ae:	3f ef       	ldi	r19, 0xFF	; 255
     5b0:	83 ed       	ldi	r24, 0xD3	; 211
     5b2:	90 e3       	ldi	r25, 0x30	; 48
     5b4:	31 50       	subi	r19, 0x01	; 1
     5b6:	80 40       	sbci	r24, 0x00	; 0
     5b8:	90 40       	sbci	r25, 0x00	; 0
     5ba:	e1 f7       	brne	.-8      	; 0x5b4 <__stack+0x155>
     5bc:	00 c0       	rjmp	.+0      	; 0x5be <__stack+0x15f>
     5be:	00 00       	nop
     5c0:	af ef       	ldi	r26, 0xFF	; 255
     5c2:	b3 ed       	ldi	r27, 0xD3	; 211
     5c4:	20 e3       	ldi	r18, 0x30	; 48
     5c6:	a1 50       	subi	r26, 0x01	; 1
     5c8:	b0 40       	sbci	r27, 0x00	; 0
     5ca:	20 40       	sbci	r18, 0x00	; 0
     5cc:	e1 f7       	brne	.-8      	; 0x5c6 <__stack+0x167>
     5ce:	00 c0       	rjmp	.+0      	; 0x5d0 <__stack+0x171>
     5d0:	00 00       	nop
   _delay_ms(2000);
   _delay_ms(2000);
   //--------------------------
   sprintf(buffer2,"World Hello!");
     5d2:	8e 01       	movw	r16, r28
     5d4:	01 5d       	subi	r16, 0xD1	; 209
     5d6:	1f 4f       	sbci	r17, 0xFF	; 255
     5d8:	8d e0       	ldi	r24, 0x0D	; 13
     5da:	e6 ec       	ldi	r30, 0xC6	; 198
     5dc:	f0 e0       	ldi	r31, 0x00	; 0
     5de:	d8 01       	movw	r26, r16
     5e0:	01 90       	ld	r0, Z+
     5e2:	0d 92       	st	X+, r0
     5e4:	8a 95       	dec	r24
     5e6:	e1 f7       	brne	.-8      	; 0x5e0 <__stack+0x181>

   lcd_clear();
     5e8:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
   lcd_gotoxy(0,0);
     5ec:	60 e0       	ldi	r22, 0x00	; 0
     5ee:	80 e0       	ldi	r24, 0x00	; 0
     5f0:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   //---------------------------

   lcd_str_out("Write Data...");
     5f4:	83 ed       	ldi	r24, 0xD3	; 211
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_write(buffer2,strlen(buffer2),&s1);
     5fc:	f8 01       	movw	r30, r16
     5fe:	01 90       	ld	r0, Z+
     600:	00 20       	and	r0, r0
     602:	e9 f7       	brne	.-6      	; 0x5fe <__stack+0x19f>
     604:	31 97       	sbiw	r30, 0x01	; 1
     606:	bf 01       	movw	r22, r30
     608:	60 1b       	sub	r22, r16
     60a:	71 0b       	sbc	r23, r17
     60c:	ae 01       	movw	r20, r28
     60e:	43 5d       	subi	r20, 0xD3	; 211
     610:	5f 4f       	sbci	r21, 0xFF	; 255
     612:	c8 01       	movw	r24, r16
     614:	0e 94 67 0b 	call	0x16ce	; 0x16ce <pf_write>
   if(res==FR_OK)
     618:	81 11       	cpse	r24, r1
     61a:	07 c0       	rjmp	.+14     	; 0x62a <__stack+0x1cb>
   {
	   lcd_printStringXY("Done",13,3);
     61c:	43 e0       	ldi	r20, 0x03	; 3
     61e:	6d e0       	ldi	r22, 0x0D	; 13
     620:	80 e6       	ldi	r24, 0x60	; 96
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     628:	06 c0       	rjmp	.+12     	; 0x636 <__stack+0x1d7>
   }
   else lcd_printStringXY("Error",13,3);
     62a:	43 e0       	ldi	r20, 0x03	; 3
     62c:	6d e0       	ldi	r22, 0x0D	; 13
     62e:	85 e6       	ldi	r24, 0x65	; 101
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     636:	3f ef       	ldi	r19, 0xFF	; 255
     638:	83 ed       	ldi	r24, 0xD3	; 211
     63a:	90 e3       	ldi	r25, 0x30	; 48
     63c:	31 50       	subi	r19, 0x01	; 1
     63e:	80 40       	sbci	r24, 0x00	; 0
     640:	90 40       	sbci	r25, 0x00	; 0
     642:	e1 f7       	brne	.-8      	; 0x63c <__stack+0x1dd>
     644:	00 c0       	rjmp	.+0      	; 0x646 <__stack+0x1e7>
     646:	00 00       	nop
   _delay_ms(2000);

   //---------------------------------
   lcd_clear();
     648:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
   lcd_gotoxy(0,1);
     64c:	61 e0       	ldi	r22, 0x01	; 1
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
   lcd_str_out("Finalise...");
     654:	81 ee       	ldi	r24, 0xE1	; 225
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_write(0,0,&s1);//Финализируем файл 1.txt
     65c:	ae 01       	movw	r20, r28
     65e:	43 5d       	subi	r20, 0xD3	; 211
     660:	5f 4f       	sbci	r21, 0xFF	; 255
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 e0       	ldi	r24, 0x00	; 0
     668:	90 e0       	ldi	r25, 0x00	; 0
     66a:	0e 94 67 0b 	call	0x16ce	; 0x16ce <pf_write>
   if(res==FR_OK)
     66e:	81 11       	cpse	r24, r1
     670:	07 c0       	rjmp	.+14     	; 0x680 <__stack+0x221>
   {
	   lcd_printStringXY("Done",13,3);
     672:	43 e0       	ldi	r20, 0x03	; 3
     674:	6d e0       	ldi	r22, 0x0D	; 13
     676:	80 e6       	ldi	r24, 0x60	; 96
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     67e:	06 c0       	rjmp	.+12     	; 0x68c <__stack+0x22d>
   }
   else lcd_printStringXY("Error",13,3);
     680:	43 e0       	ldi	r20, 0x03	; 3
     682:	6d e0       	ldi	r22, 0x0D	; 13
     684:	85 e6       	ldi	r24, 0x65	; 101
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	0e 94 2b 01 	call	0x256	; 0x256 <lcd_printStringXY>
     68c:	af ef       	ldi	r26, 0xFF	; 255
     68e:	b3 ed       	ldi	r27, 0xD3	; 211
     690:	20 e3       	ldi	r18, 0x30	; 48
     692:	a1 50       	subi	r26, 0x01	; 1
     694:	b0 40       	sbci	r27, 0x00	; 0
     696:	20 40       	sbci	r18, 0x00	; 0
     698:	e1 f7       	brne	.-8      	; 0x692 <__stack+0x233>
     69a:	00 c0       	rjmp	.+0      	; 0x69c <__stack+0x23d>
     69c:	00 00       	nop
   _delay_ms(2000);

   
   lcd_gotoxy(0,1);
     69e:	61 e0       	ldi	r22, 0x01	; 1
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_gotoxy>
     6a6:	3f ef       	ldi	r19, 0xFF	; 255
     6a8:	83 ed       	ldi	r24, 0xD3	; 211
     6aa:	90 e3       	ldi	r25, 0x30	; 48
     6ac:	31 50       	subi	r19, 0x01	; 1
     6ae:	80 40       	sbci	r24, 0x00	; 0
     6b0:	90 40       	sbci	r25, 0x00	; 0
     6b2:	e1 f7       	brne	.-8      	; 0x6ac <__stack+0x24d>
     6b4:	00 c0       	rjmp	.+0      	; 0x6b6 <__stack+0x257>
     6b6:	00 00       	nop
   _delay_ms(2000);
   lcd_clear();
     6b8:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
   //--------------------------------------------
   lcd_str_out("Unmout SD....");
     6bc:	84 e9       	ldi	r24, 0x94	; 148
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
   res=pf_mount(0x00);//демонтируем файловую систему
     6c4:	80 e0       	ldi	r24, 0x00	; 0
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <pf_mount>
   if (res==FR_OK)
     6cc:	81 11       	cpse	r24, r1
     6ce:	05 c0       	rjmp	.+10     	; 0x6da <__stack+0x27b>
   {
	   lcd_str_out("Done");
     6d0:	80 e6       	ldi	r24, 0x60	; 96
     6d2:	90 e0       	ldi	r25, 0x00	; 0
     6d4:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     6d8:	04 c0       	rjmp	.+8      	; 0x6e2 <__stack+0x283>
   }
   else
   {
	   lcd_str_out("Error");
     6da:	85 e6       	ldi	r24, 0x65	; 101
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	0e 94 db 00 	call	0x1b6	; 0x1b6 <lcd_str_out>
     6e2:	af ef       	ldi	r26, 0xFF	; 255
     6e4:	b9 e6       	ldi	r27, 0x69	; 105
     6e6:	28 e1       	ldi	r18, 0x18	; 24
     6e8:	a1 50       	subi	r26, 0x01	; 1
     6ea:	b0 40       	sbci	r27, 0x00	; 0
     6ec:	20 40       	sbci	r18, 0x00	; 0
     6ee:	e1 f7       	brne	.-8      	; 0x6e8 <__stack+0x289>
     6f0:	00 c0       	rjmp	.+0      	; 0x6f2 <__stack+0x293>
     6f2:	00 00       	nop
   }

   _delay_ms(1000);
   lcd_clear();
     6f4:	0e 94 38 01 	call	0x270	; 0x270 <lcd_clear>
	while (1) 
    {

    }
     6f8:	ff cf       	rjmp	.-2      	; 0x6f8 <__stack+0x299>

000006fa <xmit_spi>:

//-----------------------------------------------------------------------
// SPI functions
//-----------------------------------------------------------------------
void xmit_spi (BYTE data)		// Send a byte 
{ BYTE i;
     6fa:	98 e0       	ldi	r25, 0x08	; 8

 for (i=0;i<8;i++)
  {
   if ((data&0x80)==0x00) PORTB&=~_BV(SD_DI);
     6fc:	88 23       	and	r24, r24
     6fe:	14 f0       	brlt	.+4      	; 0x704 <xmit_spi+0xa>
     700:	c5 98       	cbi	0x18, 5	; 24
     702:	01 c0       	rjmp	.+2      	; 0x706 <xmit_spi+0xc>
                     else PORTB|=_BV(SD_DI);
     704:	c5 9a       	sbi	0x18, 5	; 24
   data=data<<1; 
     706:	88 0f       	add	r24, r24
   PORTB|=_BV(SD_CLK);
     708:	c7 9a       	sbi	0x18, 7	; 24
   asm("nop"); 
     70a:	00 00       	nop
   PORTB&=~_BV(SD_CLK);
     70c:	c7 98       	cbi	0x18, 7	; 24
     70e:	91 50       	subi	r25, 0x01	; 1
// SPI functions
//-----------------------------------------------------------------------
void xmit_spi (BYTE data)		// Send a byte 
{ BYTE i;

 for (i=0;i<8;i++)
     710:	a9 f7       	brne	.-22     	; 0x6fc <xmit_spi+0x2>
   data=data<<1; 
   PORTB|=_BV(SD_CLK);
   asm("nop"); 
   PORTB&=~_BV(SD_CLK);
  }
}
     712:	08 95       	ret

00000714 <rcv_spi>:

BYTE rcv_spi (void)				// Send 0xFF and receive a byte 
{ BYTE i, res=0;

 PORTB|=_BV(SD_DI);
     714:	c5 9a       	sbi	0x18, 5	; 24
     716:	98 e0       	ldi	r25, 0x08	; 8
   PORTB&=~_BV(SD_CLK);
  }
}

BYTE rcv_spi (void)				// Send 0xFF and receive a byte 
{ BYTE i, res=0;
     718:	80 e0       	ldi	r24, 0x00	; 0

 PORTB|=_BV(SD_DI);

 for (i=0;i<8;i++)
  {
   PORTB|=_BV(SD_CLK);
     71a:	c7 9a       	sbi	0x18, 7	; 24
   res=res<<1;
     71c:	88 0f       	add	r24, r24
   if ((PINB&_BV(SD_DO))!=0x00) res=res|0x01;
     71e:	b6 99       	sbic	0x16, 6	; 22
     720:	81 60       	ori	r24, 0x01	; 1
   PORTB&=~_BV(SD_CLK);
     722:	c7 98       	cbi	0x18, 7	; 24
   asm("nop");
     724:	00 00       	nop
     726:	91 50       	subi	r25, 0x01	; 1
BYTE rcv_spi (void)				// Send 0xFF and receive a byte 
{ BYTE i, res=0;

 PORTB|=_BV(SD_DI);

 for (i=0;i<8;i++)
     728:	c1 f7       	brne	.-16     	; 0x71a <rcv_spi+0x6>
   if ((PINB&_BV(SD_DO))!=0x00) res=res|0x01;
   PORTB&=~_BV(SD_CLK);
   asm("nop");
  }
 return res;
}	/* Send 0xFF and receive a byte */
     72a:	08 95       	ret

0000072c <send_cmd>:
static
BYTE send_cmd (
	BYTE cmd,		// Command byte 
	DWORD arg		// Argument 
)
{
     72c:	ff 92       	push	r15
     72e:	0f 93       	push	r16
     730:	1f 93       	push	r17
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	c8 2f       	mov	r28, r24
     738:	d4 2f       	mov	r29, r20
     73a:	15 2f       	mov	r17, r21
     73c:	06 2f       	mov	r16, r22
     73e:	f7 2e       	mov	r15, r23
	BYTE n, res;


	if (cmd & 0x80) {	// ACMD<n> is the command sequense of CMD55-CMD<n> 
     740:	88 23       	and	r24, r24
     742:	4c f4       	brge	.+18     	; 0x756 <send_cmd+0x2a>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
     744:	40 e0       	ldi	r20, 0x00	; 0
     746:	50 e0       	ldi	r21, 0x00	; 0
     748:	ba 01       	movw	r22, r20
     74a:	87 e7       	ldi	r24, 0x77	; 119
     74c:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
		if (res > 1) return res;
     750:	82 30       	cpi	r24, 0x02	; 2
     752:	40 f5       	brcc	.+80     	; 0x7a4 <send_cmd+0x78>
{
	BYTE n, res;


	if (cmd & 0x80) {	// ACMD<n> is the command sequense of CMD55-CMD<n> 
		cmd &= 0x7F;
     754:	cf 77       	andi	r28, 0x7F	; 127
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	// Select the card 
	DESELECT();
     756:	c4 9a       	sbi	0x18, 4	; 24
	rcv_spi();
     758:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
	SELECT();
     75c:	c4 98       	cbi	0x18, 4	; 24
	rcv_spi();
     75e:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>

	// Send a command packet 
	xmit_spi(cmd);						// Start + Command index 
     762:	8c 2f       	mov	r24, r28
     764:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
	xmit_spi((BYTE)(arg >> 24));		// Argument[31..24] 
     768:	8f 2d       	mov	r24, r15
     76a:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
	xmit_spi((BYTE)(arg >> 16));		// Argument[23..16] 
     76e:	80 2f       	mov	r24, r16
     770:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
	xmit_spi((BYTE)(arg >> 8));			// Argument[15..8] 
     774:	81 2f       	mov	r24, r17
     776:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
	xmit_spi((BYTE)arg);				// Argument[7..0] 
     77a:	8d 2f       	mov	r24, r29
     77c:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
	n = 0x01;							// Dummy CRC + Stop 
	if (cmd == CMD0) n = 0x95;			// Valid CRC for CMD0(0) 
     780:	c0 34       	cpi	r28, 0x40	; 64
     782:	21 f0       	breq	.+8      	; 0x78c <send_cmd+0x60>
	if (cmd == CMD8) n = 0x87;			// Valid CRC for CMD8(0x1AA) 
     784:	c8 34       	cpi	r28, 0x48	; 72
     786:	21 f4       	brne	.+8      	; 0x790 <send_cmd+0x64>
     788:	87 e8       	ldi	r24, 0x87	; 135
     78a:	03 c0       	rjmp	.+6      	; 0x792 <send_cmd+0x66>
	xmit_spi((BYTE)(arg >> 24));		// Argument[31..24] 
	xmit_spi((BYTE)(arg >> 16));		// Argument[23..16] 
	xmit_spi((BYTE)(arg >> 8));			// Argument[15..8] 
	xmit_spi((BYTE)arg);				// Argument[7..0] 
	n = 0x01;							// Dummy CRC + Stop 
	if (cmd == CMD0) n = 0x95;			// Valid CRC for CMD0(0) 
     78c:	85 e9       	ldi	r24, 0x95	; 149
     78e:	01 c0       	rjmp	.+2      	; 0x792 <send_cmd+0x66>
	xmit_spi(cmd);						// Start + Command index 
	xmit_spi((BYTE)(arg >> 24));		// Argument[31..24] 
	xmit_spi((BYTE)(arg >> 16));		// Argument[23..16] 
	xmit_spi((BYTE)(arg >> 8));			// Argument[15..8] 
	xmit_spi((BYTE)arg);				// Argument[7..0] 
	n = 0x01;							// Dummy CRC + Stop 
     790:	81 e0       	ldi	r24, 0x01	; 1
	if (cmd == CMD0) n = 0x95;			// Valid CRC for CMD0(0) 
	if (cmd == CMD8) n = 0x87;			// Valid CRC for CMD8(0x1AA) 
	xmit_spi(n);
     792:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
     796:	ca e0       	ldi	r28, 0x0A	; 10

	// Receive a command response 
	n = 10;								// Wait for a valid response in timeout of 10 attempts 
	do {
		res = rcv_spi();
     798:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
	} while ((res & 0x80) && --n);
     79c:	88 23       	and	r24, r24
     79e:	14 f4       	brge	.+4      	; 0x7a4 <send_cmd+0x78>
     7a0:	c1 50       	subi	r28, 0x01	; 1
     7a2:	d1 f7       	brne	.-12     	; 0x798 <send_cmd+0x6c>

	return res;			// Return with the response value 
}
     7a4:	df 91       	pop	r29
     7a6:	cf 91       	pop	r28
     7a8:	1f 91       	pop	r17
     7aa:	0f 91       	pop	r16
     7ac:	ff 90       	pop	r15
     7ae:	08 95       	ret

000007b0 <disk_readp>:
	BYTE *buff,		// Pointer to the read buffer (NULL:Read bytes are forwarded to the stream) 
	DWORD lba,		// Sector number (LBA) 
	WORD ofs,		// Byte offset to read from (0..511) 
	WORD cnt		// Number of bytes to read (ofs + cnt mus be <= 512) 
)
{
     7b0:	cf 92       	push	r12
     7b2:	df 92       	push	r13
     7b4:	ef 92       	push	r14
     7b6:	ff 92       	push	r15
     7b8:	0f 93       	push	r16
     7ba:	1f 93       	push	r17
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	7c 01       	movw	r14, r24
     7c2:	69 01       	movw	r12, r18
	BYTE rc;
	WORD bc;

//	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;

	if (!(CardType & CT_BLOCK))
     7c4:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <CardType>
     7c8:	83 fd       	sbrc	r24, 3
     7ca:	09 c0       	rjmp	.+18     	; 0x7de <disk_readp+0x2e>
	{
		lba *= 512;		// Convert to byte address if needed 
     7cc:	03 2e       	mov	r0, r19
     7ce:	39 e0       	ldi	r19, 0x09	; 9
     7d0:	44 0f       	add	r20, r20
     7d2:	55 1f       	adc	r21, r21
     7d4:	66 1f       	adc	r22, r22
     7d6:	77 1f       	adc	r23, r23
     7d8:	3a 95       	dec	r19
     7da:	d1 f7       	brne	.-12     	; 0x7d0 <disk_readp+0x20>
     7dc:	30 2d       	mov	r19, r0
	}
	res = RES_ERROR;
	if (send_cmd(CMD17, lba) == 0) {		// READ_SINGLE_BLOCK 
     7de:	81 e5       	ldi	r24, 0x51	; 81
     7e0:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     7e4:	81 11       	cpse	r24, r1
     7e6:	30 c0       	rjmp	.+96     	; 0x848 <disk_readp+0x98>
     7e8:	c0 e3       	ldi	r28, 0x30	; 48
     7ea:	d5 e7       	ldi	r29, 0x75	; 117
		bc = 30000;
		do {							// Wait for data packet in timeout of 100ms 
			rc = rcv_spi();
     7ec:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
		} while (rc == 0xFF && --bc);
     7f0:	8f 3f       	cpi	r24, 0xFF	; 255
     7f2:	21 f4       	brne	.+8      	; 0x7fc <disk_readp+0x4c>
     7f4:	21 97       	sbiw	r28, 0x01	; 1
     7f6:	d1 f7       	brne	.-12     	; 0x7ec <disk_readp+0x3c>

	if (!(CardType & CT_BLOCK))
	{
		lba *= 512;		// Convert to byte address if needed 
	}
	res = RES_ERROR;
     7f8:	c1 e0       	ldi	r28, 0x01	; 1
     7fa:	29 c0       	rjmp	.+82     	; 0x84e <disk_readp+0x9e>
		bc = 30000;
		do {							// Wait for data packet in timeout of 100ms 
			rc = rcv_spi();
		} while (rc == 0xFF && --bc);

		if (rc == 0xFE) {				// A data packet arrived 
     7fc:	8e 3f       	cpi	r24, 0xFE	; 254
     7fe:	31 f5       	brne	.+76     	; 0x84c <disk_readp+0x9c>
     800:	c2 e0       	ldi	r28, 0x02	; 2
     802:	d2 e0       	ldi	r29, 0x02	; 2
     804:	c0 1b       	sub	r28, r16
     806:	d1 0b       	sbc	r29, r17
			bc = 514 - ofs - cnt;
     808:	cc 19       	sub	r28, r12
     80a:	dd 09       	sbc	r29, r13

			// Skip leading bytes 
			if (ofs) {
     80c:	c1 14       	cp	r12, r1
     80e:	d1 04       	cpc	r13, r1
     810:	31 f0       	breq	.+12     	; 0x81e <disk_readp+0x6e>
				do rcv_spi(); while (--ofs);
     812:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     816:	81 e0       	ldi	r24, 0x01	; 1
     818:	c8 1a       	sub	r12, r24
     81a:	d1 08       	sbc	r13, r1
     81c:	d1 f7       	brne	.-12     	; 0x812 <disk_readp+0x62>
			}

			// Receive a part of the sector 
			if (buff) {	// Store data to the memory 
     81e:	e1 14       	cp	r14, r1
     820:	f1 04       	cpc	r15, r1
     822:	49 f0       	breq	.+18     	; 0x836 <disk_readp+0x86>
				do
					*buff++ = rcv_spi();
     824:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     828:	f7 01       	movw	r30, r14
     82a:	81 93       	st	Z+, r24
     82c:	7f 01       	movw	r14, r30
				while (--cnt);
     82e:	01 50       	subi	r16, 0x01	; 1
     830:	11 09       	sbc	r17, r1
     832:	c1 f7       	brne	.-16     	; 0x824 <disk_readp+0x74>
     834:	03 c0       	rjmp	.+6      	; 0x83c <disk_readp+0x8c>
			} else {	// Forward data to the outgoing stream (depends on the project) 
				do 
                ;//uart_transmit(rcv_spi());		// (Console output) 
				while (--cnt);
     836:	01 50       	subi	r16, 0x01	; 1
     838:	11 09       	sbc	r17, r1
     83a:	e9 f7       	brne	.-6      	; 0x836 <disk_readp+0x86>
			}

			// Skip trailing bytes and CRC 
			do rcv_spi(); while (--bc);
     83c:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     840:	21 97       	sbiw	r28, 0x01	; 1
     842:	e1 f7       	brne	.-8      	; 0x83c <disk_readp+0x8c>

			res = RES_OK;
     844:	c0 e0       	ldi	r28, 0x00	; 0
     846:	03 c0       	rjmp	.+6      	; 0x84e <disk_readp+0x9e>

	if (!(CardType & CT_BLOCK))
	{
		lba *= 512;		// Convert to byte address if needed 
	}
	res = RES_ERROR;
     848:	c1 e0       	ldi	r28, 0x01	; 1
     84a:	01 c0       	rjmp	.+2      	; 0x84e <disk_readp+0x9e>
     84c:	c1 e0       	ldi	r28, 0x01	; 1
// Deselect the card and release SPI bus                                 
//-----------------------------------------------------------------------
static
void release_spi (void)
{
	rcv_spi();
     84e:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
	}

	release_spi();

	return res;
}
     852:	8c 2f       	mov	r24, r28
     854:	df 91       	pop	r29
     856:	cf 91       	pop	r28
     858:	1f 91       	pop	r17
     85a:	0f 91       	pop	r16
     85c:	ff 90       	pop	r15
     85e:	ef 90       	pop	r14
     860:	df 90       	pop	r13
     862:	cf 90       	pop	r12
     864:	08 95       	ret

00000866 <disk_writep>:

DRESULT disk_writep (
	const BYTE *buff,	// Pointer to the bytes to be written (NULL:Initiate/Finalize sector write) 
	DWORD sa			// Number of bytes to send, Sector number (LBA) or zero 
)
{
     866:	ef 92       	push	r14
     868:	ff 92       	push	r15
     86a:	0f 93       	push	r16
     86c:	1f 93       	push	r17
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
// 	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
// 	if ((PINB&_BV(SD_WP))!=0x00) return RES_ERROR;

	res = RES_ERROR;

	if (buff) {		// Send data bytes 
     872:	00 97       	sbiw	r24, 0x00	; 0
     874:	f1 f0       	breq	.+60     	; 0x8b2 <disk_writep+0x4c>
		bc = (WORD)sa;
     876:	8a 01       	movw	r16, r20
		while (bc && wc) {		// Send data bytes to the card 
     878:	45 2b       	or	r20, r21
     87a:	09 f4       	brne	.+2      	; 0x87e <disk_writep+0x18>
     87c:	6a c0       	rjmp	.+212    	; 0x952 <disk_writep+0xec>
     87e:	c0 91 ee 00 	lds	r28, 0x00EE	; 0x8000ee <__data_end>
     882:	d0 91 ef 00 	lds	r29, 0x00EF	; 0x8000ef <__data_end+0x1>
     886:	20 97       	sbiw	r28, 0x00	; 0
     888:	09 f4       	brne	.+2      	; 0x88c <disk_writep+0x26>
     88a:	65 c0       	rjmp	.+202    	; 0x956 <disk_writep+0xf0>
     88c:	7c 01       	movw	r14, r24
			xmit_spi(*buff++);
     88e:	f7 01       	movw	r30, r14
     890:	81 91       	ld	r24, Z+
     892:	7f 01       	movw	r14, r30
     894:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
			wc--; bc--;
     898:	21 97       	sbiw	r28, 0x01	; 1
     89a:	d0 93 ef 00 	sts	0x00EF, r29	; 0x8000ef <__data_end+0x1>
     89e:	c0 93 ee 00 	sts	0x00EE, r28	; 0x8000ee <__data_end>
     8a2:	01 50       	subi	r16, 0x01	; 1
     8a4:	11 09       	sbc	r17, r1

	res = RES_ERROR;

	if (buff) {		// Send data bytes 
		bc = (WORD)sa;
		while (bc && wc) {		// Send data bytes to the card 
     8a6:	09 f4       	brne	.+2      	; 0x8aa <disk_writep+0x44>
     8a8:	58 c0       	rjmp	.+176    	; 0x95a <disk_writep+0xf4>
     8aa:	20 97       	sbiw	r28, 0x00	; 0
     8ac:	81 f7       	brne	.-32     	; 0x88e <disk_writep+0x28>
			xmit_spi(*buff++);
			wc--; bc--;
		}
		res = RES_OK;
     8ae:	c0 e0       	ldi	r28, 0x00	; 0
     8b0:	57 c0       	rjmp	.+174    	; 0x960 <disk_writep+0xfa>
	} else {
		if (sa) {	// Initiate sector write process 
     8b2:	41 15       	cp	r20, r1
     8b4:	51 05       	cpc	r21, r1
     8b6:	61 05       	cpc	r22, r1
     8b8:	71 05       	cpc	r23, r1
     8ba:	01 f1       	breq	.+64     	; 0x8fc <disk_writep+0x96>
			if (!(CardType & CT_BLOCK)) sa *= 512;	// Convert to byte address if needed 
     8bc:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <CardType>
     8c0:	83 fd       	sbrc	r24, 3
     8c2:	09 c0       	rjmp	.+18     	; 0x8d6 <disk_writep+0x70>
     8c4:	03 2e       	mov	r0, r19
     8c6:	39 e0       	ldi	r19, 0x09	; 9
     8c8:	44 0f       	add	r20, r20
     8ca:	55 1f       	adc	r21, r21
     8cc:	66 1f       	adc	r22, r22
     8ce:	77 1f       	adc	r23, r23
     8d0:	3a 95       	dec	r19
     8d2:	d1 f7       	brne	.-12     	; 0x8c8 <disk_writep+0x62>
     8d4:	30 2d       	mov	r19, r0
			if (send_cmd(CMD24, sa) == 0) {			// WRITE_SINGLE_BLOCK 
     8d6:	88 e5       	ldi	r24, 0x58	; 88
     8d8:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     8dc:	81 11       	cpse	r24, r1
     8de:	3f c0       	rjmp	.+126    	; 0x95e <disk_writep+0xf8>
				xmit_spi(0xFF); xmit_spi(0xFE);		// Data block header 
     8e0:	8f ef       	ldi	r24, 0xFF	; 255
     8e2:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
     8e6:	8e ef       	ldi	r24, 0xFE	; 254
     8e8:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
				wc = 512;							// Set byte counter 
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	92 e0       	ldi	r25, 0x02	; 2
     8f0:	90 93 ef 00 	sts	0x00EF, r25	; 0x8000ef <__data_end+0x1>
     8f4:	80 93 ee 00 	sts	0x00EE, r24	; 0x8000ee <__data_end>
				res = RES_OK;
     8f8:	c0 e0       	ldi	r28, 0x00	; 0
     8fa:	32 c0       	rjmp	.+100    	; 0x960 <disk_writep+0xfa>
			}
		} else {	// Finalize sector write process 
			bc = wc + 2;
     8fc:	c0 91 ee 00 	lds	r28, 0x00EE	; 0x8000ee <__data_end>
     900:	d0 91 ef 00 	lds	r29, 0x00EF	; 0x8000ef <__data_end+0x1>
			while (bc--) xmit_spi(0);	// Fill left bytes and CRC with zeros 
     904:	ce 3f       	cpi	r28, 0xFE	; 254
     906:	ff ef       	ldi	r31, 0xFF	; 255
     908:	df 07       	cpc	r29, r31
     90a:	11 f4       	brne	.+4      	; 0x910 <disk_writep+0xaa>
     90c:	08 c0       	rjmp	.+16     	; 0x91e <disk_writep+0xb8>
     90e:	ec 01       	movw	r28, r24
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	0e 94 7d 03 	call	0x6fa	; 0x6fa <xmit_spi>
     916:	ce 01       	movw	r24, r28
     918:	01 97       	sbiw	r24, 0x01	; 1
     91a:	21 96       	adiw	r28, 0x01	; 1
     91c:	c1 f7       	brne	.-16     	; 0x90e <disk_writep+0xa8>
			if ((rcv_spi() & 0x1F) == 0x05) {	// Receive data resp and wait for end of write process in timeout of 300ms 
     91e:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     922:	8f 71       	andi	r24, 0x1F	; 31
     924:	85 30       	cpi	r24, 0x05	; 5
     926:	29 f0       	breq	.+10     	; 0x932 <disk_writep+0xcc>
	static WORD wc;

// 	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
// 	if ((PINB&_BV(SD_WP))!=0x00) return RES_ERROR;

	res = RES_ERROR;
     928:	c1 e0       	ldi	r28, 0x01	; 1
     92a:	10 c0       	rjmp	.+32     	; 0x94c <disk_writep+0xe6>
			}
		} else {	// Finalize sector write process 
			bc = wc + 2;
			while (bc--) xmit_spi(0);	// Fill left bytes and CRC with zeros 
			if ((rcv_spi() & 0x1F) == 0x05) {	// Receive data resp and wait for end of write process in timeout of 300ms 
				for (bc = 65000; rcv_spi() != 0xFF && bc; bc--) ;	// Wait ready 
     92c:	01 50       	subi	r16, 0x01	; 1
     92e:	11 09       	sbc	r17, r1
     930:	02 c0       	rjmp	.+4      	; 0x936 <disk_writep+0xd0>
     932:	08 ee       	ldi	r16, 0xE8	; 232
     934:	1d ef       	ldi	r17, 0xFD	; 253
     936:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     93a:	8f 3f       	cpi	r24, 0xFF	; 255
     93c:	19 f0       	breq	.+6      	; 0x944 <disk_writep+0xde>
     93e:	01 15       	cp	r16, r1
     940:	11 05       	cpc	r17, r1
     942:	a1 f7       	brne	.-24     	; 0x92c <disk_writep+0xc6>
				if (bc) res = RES_OK;
     944:	c1 e0       	ldi	r28, 0x01	; 1
     946:	01 2b       	or	r16, r17
     948:	09 f0       	breq	.+2      	; 0x94c <disk_writep+0xe6>
     94a:	c0 e0       	ldi	r28, 0x00	; 0
// Deselect the card and release SPI bus                                 
//-----------------------------------------------------------------------
static
void release_spi (void)
{
	rcv_spi();
     94c:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     950:	07 c0       	rjmp	.+14     	; 0x960 <disk_writep+0xfa>
		bc = (WORD)sa;
		while (bc && wc) {		// Send data bytes to the card 
			xmit_spi(*buff++);
			wc--; bc--;
		}
		res = RES_OK;
     952:	c0 e0       	ldi	r28, 0x00	; 0
     954:	05 c0       	rjmp	.+10     	; 0x960 <disk_writep+0xfa>
     956:	c0 e0       	ldi	r28, 0x00	; 0
     958:	03 c0       	rjmp	.+6      	; 0x960 <disk_writep+0xfa>
     95a:	c0 e0       	ldi	r28, 0x00	; 0
     95c:	01 c0       	rjmp	.+2      	; 0x960 <disk_writep+0xfa>
	static WORD wc;

// 	if ((PINB&_BV(SD_INS))!=0x00) return RES_ERROR;
// 	if ((PINB&_BV(SD_WP))!=0x00) return RES_ERROR;

	res = RES_ERROR;
     95e:	c1 e0       	ldi	r28, 0x01	; 1
			release_spi();
		}
	}

	return res;
}
     960:	8c 2f       	mov	r24, r28
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	ff 90       	pop	r15
     96c:	ef 90       	pop	r14
     96e:	08 95       	ret

00000970 <disk_initialize>:

//--------------------------------------------------------------------------
// Initialize Disk Drive                                                 
//--------------------------------------------------------------------------
DSTATUS disk_initialize (void)
{
     970:	cf 92       	push	r12
     972:	df 92       	push	r13
     974:	ef 92       	push	r14
     976:	ff 92       	push	r15
     978:	0f 93       	push	r16
     97a:	1f 93       	push	r17
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	00 d0       	rcall	.+0      	; 0x982 <disk_initialize+0x12>
     982:	00 d0       	rcall	.+0      	; 0x984 <disk_initialize+0x14>
     984:	cd b7       	in	r28, 0x3d	; 61
     986:	de b7       	in	r29, 0x3e	; 62
	BYTE n, cmd, ty, ocr[4];
	WORD tmr;


	INIT_SPI();
     988:	80 e7       	ldi	r24, 0x70	; 112
     98a:	88 bb       	out	0x18, r24	; 24
     98c:	80 eb       	ldi	r24, 0xB0	; 176
     98e:	87 bb       	out	0x17, r24	; 23

//	if ((PINB&_BV(SD_INS))!=0x00) return STA_NOINIT;

#if _WRITE_FUNC
	if (MMC_SEL) disk_writep(0, 0);		// Finalize write process if it is in progress 
     990:	c4 99       	sbic	0x18, 4	; 24
     992:	ad c0       	rjmp	.+346    	; 0xaee <disk_initialize+0x17e>
     994:	40 e0       	ldi	r20, 0x00	; 0
     996:	50 e0       	ldi	r21, 0x00	; 0
     998:	ba 01       	movw	r22, r20
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	0e 94 33 04 	call	0x866	; 0x866 <disk_writep>
     9a2:	a5 c0       	rjmp	.+330    	; 0xaee <disk_initialize+0x17e>
#endif
	for (n = 100; n; n--) rcv_spi();	// Dummy clocks 
     9a4:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     9a8:	11 50       	subi	r17, 0x01	; 1
     9aa:	e1 f7       	brne	.-8      	; 0x9a4 <disk_initialize+0x34>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			// Enter Idle state 
     9ac:	40 e0       	ldi	r20, 0x00	; 0
     9ae:	50 e0       	ldi	r21, 0x00	; 0
     9b0:	ba 01       	movw	r22, r20
     9b2:	80 e4       	ldi	r24, 0x40	; 64
     9b4:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     9b8:	81 30       	cpi	r24, 0x01	; 1
     9ba:	09 f0       	breq	.+2      	; 0x9be <disk_initialize+0x4e>
     9bc:	7d c0       	rjmp	.+250    	; 0xab8 <disk_initialize+0x148>
		if (send_cmd(CMD8, 0x1AA) == 1) {	// SDv2 
     9be:	4a ea       	ldi	r20, 0xAA	; 170
     9c0:	51 e0       	ldi	r21, 0x01	; 1
     9c2:	60 e0       	ldi	r22, 0x00	; 0
     9c4:	70 e0       	ldi	r23, 0x00	; 0
     9c6:	88 e4       	ldi	r24, 0x48	; 72
     9c8:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     9cc:	81 30       	cpi	r24, 0x01	; 1
     9ce:	09 f0       	breq	.+2      	; 0x9d2 <disk_initialize+0x62>
     9d0:	42 c0       	rjmp	.+132    	; 0xa56 <disk_initialize+0xe6>
     9d2:	ce 01       	movw	r24, r28
     9d4:	01 96       	adiw	r24, 0x01	; 1
     9d6:	7c 01       	movw	r14, r24
     9d8:	6e 01       	movw	r12, r28
     9da:	95 e0       	ldi	r25, 0x05	; 5
     9dc:	c9 0e       	add	r12, r25
     9de:	d1 1c       	adc	r13, r1
     9e0:	87 01       	movw	r16, r14

// 	  		setpos(0,3);
// 	  		str_lcd("SDv2");

			for (n = 0; n < 4; n++) ocr[n] = rcv_spi();		// Get trailing return value of R7 resp 
     9e2:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     9e6:	f8 01       	movw	r30, r16
     9e8:	81 93       	st	Z+, r24
     9ea:	8f 01       	movw	r16, r30
     9ec:	ec 15       	cp	r30, r12
     9ee:	fd 05       	cpc	r31, r13
     9f0:	c1 f7       	brne	.-16     	; 0x9e2 <disk_initialize+0x72>
//  			sprintf(str,"%02X",ocr[1]);
//  			str_lcd(str);
//  			setpos(17,0);
//  			sprintf(str,"%02X",ocr[0]);
//  			str_lcd(str);
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				// The card can work at vdd range of 2.7-3.6V 
     9f2:	8b 81       	ldd	r24, Y+3	; 0x03
     9f4:	81 30       	cpi	r24, 0x01	; 1
     9f6:	09 f0       	breq	.+2      	; 0x9fa <disk_initialize+0x8a>
     9f8:	61 c0       	rjmp	.+194    	; 0xabc <disk_initialize+0x14c>
     9fa:	8c 81       	ldd	r24, Y+4	; 0x04
     9fc:	8a 3a       	cpi	r24, 0xAA	; 170
     9fe:	31 f0       	breq	.+12     	; 0xa0c <disk_initialize+0x9c>
#if _WRITE_FUNC
	if (MMC_SEL) disk_writep(0, 0);		// Finalize write process if it is in progress 
#endif
	for (n = 100; n; n--) rcv_spi();	// Dummy clocks 

	ty = 0;
     a00:	f1 2c       	mov	r15, r1
     a02:	6c c0       	rjmp	.+216    	; 0xadc <disk_initialize+0x16c>
//  			sprintf(str,"%02X",ocr[0]);
//  			str_lcd(str);
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				// The card can work at vdd range of 2.7-3.6V 
// 	  		setpos(5,3);
// 	  		str_lcd("AA01");
				for (tmr = 12000; tmr && send_cmd(ACMD41, 1UL << 30); tmr--) ;	// Wait for leaving idle state (ACMD41 with HCS bit) 
     a04:	01 50       	subi	r16, 0x01	; 1
     a06:	11 09       	sbc	r17, r1
     a08:	19 f4       	brne	.+6      	; 0xa10 <disk_initialize+0xa0>
     a0a:	5a c0       	rjmp	.+180    	; 0xac0 <disk_initialize+0x150>
     a0c:	00 ee       	ldi	r16, 0xE0	; 224
     a0e:	1e e2       	ldi	r17, 0x2E	; 46
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	60 e0       	ldi	r22, 0x00	; 0
     a16:	70 e4       	ldi	r23, 0x40	; 64
     a18:	89 ee       	ldi	r24, 0xE9	; 233
     a1a:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     a1e:	81 11       	cpse	r24, r1
     a20:	f1 cf       	rjmp	.-30     	; 0xa04 <disk_initialize+0x94>
				if (tmr && send_cmd(CMD58, 0) == 0) {		// Check CCS bit in the OCR 
     a22:	01 2b       	or	r16, r17
     a24:	09 f4       	brne	.+2      	; 0xa28 <disk_initialize+0xb8>
     a26:	4e c0       	rjmp	.+156    	; 0xac4 <disk_initialize+0x154>
     a28:	40 e0       	ldi	r20, 0x00	; 0
     a2a:	50 e0       	ldi	r21, 0x00	; 0
     a2c:	ba 01       	movw	r22, r20
     a2e:	8a e7       	ldi	r24, 0x7A	; 122
     a30:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     a34:	81 11       	cpse	r24, r1
     a36:	48 c0       	rjmp	.+144    	; 0xac8 <disk_initialize+0x158>
// 			  		setpos(10,3);
// 					str_lcd("CCS");
					for (n = 0; n < 4; n++) ocr[n] = rcv_spi();
     a38:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
     a3c:	f7 01       	movw	r30, r14
     a3e:	81 93       	st	Z+, r24
     a40:	7f 01       	movw	r14, r30
     a42:	ec 15       	cp	r30, r12
     a44:	fd 05       	cpc	r31, r13
     a46:	c1 f7       	brne	.-16     	; 0xa38 <disk_initialize+0xc8>
//  					sprintf(str,"%02X",ocr[1]);
//  					str_lcd(str);
//  					setpos(17,1);
//  					sprintf(str,"%02X",ocr[0]);
//  					str_lcd(str);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	// SDv2 (HC or SC) 
     a48:	89 81       	ldd	r24, Y+1	; 0x01
     a4a:	86 fd       	sbrc	r24, 6
     a4c:	3f c0       	rjmp	.+126    	; 0xacc <disk_initialize+0x15c>
     a4e:	68 94       	set
     a50:	ff 24       	eor	r15, r15
     a52:	f2 f8       	bld	r15, 2
     a54:	43 c0       	rjmp	.+134    	; 0xadc <disk_initialize+0x16c>
				}
			}
		} else {							// SDv1 or MMCv3 
			if (send_cmd(ACMD41, 0) <= 1) 	{
     a56:	40 e0       	ldi	r20, 0x00	; 0
     a58:	50 e0       	ldi	r21, 0x00	; 0
     a5a:	ba 01       	movw	r22, r20
     a5c:	89 ee       	ldi	r24, 0xE9	; 233
     a5e:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     a62:	82 30       	cpi	r24, 0x02	; 2
     a64:	38 f0       	brcs	.+14     	; 0xa74 <disk_initialize+0x104>
				ty = CT_SD1; cmd = ACMD41;	// SDv1 
			} else {
				ty = CT_MMC; cmd = CMD1;	// MMCv3 
     a66:	ff 24       	eor	r15, r15
     a68:	f3 94       	inc	r15
     a6a:	0f 2e       	mov	r0, r31
     a6c:	f1 e4       	ldi	r31, 0x41	; 65
     a6e:	ef 2e       	mov	r14, r31
     a70:	f0 2d       	mov	r31, r0
     a72:	07 c0       	rjmp	.+14     	; 0xa82 <disk_initialize+0x112>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	// SDv2 (HC or SC) 
				}
			}
		} else {							// SDv1 or MMCv3 
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	// SDv1 
     a74:	68 94       	set
     a76:	ff 24       	eor	r15, r15
     a78:	f1 f8       	bld	r15, 1
     a7a:	0f 2e       	mov	r0, r31
     a7c:	f9 ee       	ldi	r31, 0xE9	; 233
     a7e:	ef 2e       	mov	r14, r31
     a80:	f0 2d       	mov	r31, r0
			} else {
				ty = CT_MMC; cmd = CMD1;	// MMCv3 
			}
			for (tmr = 25000; tmr && send_cmd(cmd, 0); tmr--) ;	// Wait for leaving idle state 
     a82:	08 ea       	ldi	r16, 0xA8	; 168
     a84:	11 e6       	ldi	r17, 0x61	; 97
     a86:	03 c0       	rjmp	.+6      	; 0xa8e <disk_initialize+0x11e>
     a88:	01 50       	subi	r16, 0x01	; 1
     a8a:	11 09       	sbc	r17, r1
     a8c:	21 f1       	breq	.+72     	; 0xad6 <disk_initialize+0x166>
     a8e:	40 e0       	ldi	r20, 0x00	; 0
     a90:	50 e0       	ldi	r21, 0x00	; 0
     a92:	ba 01       	movw	r22, r20
     a94:	8e 2d       	mov	r24, r14
     a96:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     a9a:	81 11       	cpse	r24, r1
     a9c:	f5 cf       	rjmp	.-22     	; 0xa88 <disk_initialize+0x118>
			if (!tmr || send_cmd(CMD16, 512) != 0)			// Set R/W block length to 512 
     a9e:	01 2b       	or	r16, r17
     aa0:	e1 f0       	breq	.+56     	; 0xada <disk_initialize+0x16a>
     aa2:	40 e0       	ldi	r20, 0x00	; 0
     aa4:	52 e0       	ldi	r21, 0x02	; 2
     aa6:	60 e0       	ldi	r22, 0x00	; 0
     aa8:	70 e0       	ldi	r23, 0x00	; 0
     aaa:	80 e5       	ldi	r24, 0x50	; 80
     aac:	0e 94 96 03 	call	0x72c	; 0x72c <send_cmd>
     ab0:	88 23       	and	r24, r24
     ab2:	a1 f0       	breq	.+40     	; 0xadc <disk_initialize+0x16c>
				ty = 0;
     ab4:	f1 2c       	mov	r15, r1
     ab6:	12 c0       	rjmp	.+36     	; 0xadc <disk_initialize+0x16c>
#if _WRITE_FUNC
	if (MMC_SEL) disk_writep(0, 0);		// Finalize write process if it is in progress 
#endif
	for (n = 100; n; n--) rcv_spi();	// Dummy clocks 

	ty = 0;
     ab8:	f1 2c       	mov	r15, r1
     aba:	10 c0       	rjmp	.+32     	; 0xadc <disk_initialize+0x16c>
     abc:	f1 2c       	mov	r15, r1
     abe:	0e c0       	rjmp	.+28     	; 0xadc <disk_initialize+0x16c>
     ac0:	f1 2c       	mov	r15, r1
     ac2:	0c c0       	rjmp	.+24     	; 0xadc <disk_initialize+0x16c>
     ac4:	f1 2c       	mov	r15, r1
     ac6:	0a c0       	rjmp	.+20     	; 0xadc <disk_initialize+0x16c>
     ac8:	f1 2c       	mov	r15, r1
     aca:	08 c0       	rjmp	.+16     	; 0xadc <disk_initialize+0x16c>
//  					sprintf(str,"%02X",ocr[1]);
//  					str_lcd(str);
//  					setpos(17,1);
//  					sprintf(str,"%02X",ocr[0]);
//  					str_lcd(str);
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	// SDv2 (HC or SC) 
     acc:	0f 2e       	mov	r0, r31
     ace:	fc e0       	ldi	r31, 0x0C	; 12
     ad0:	ff 2e       	mov	r15, r31
     ad2:	f0 2d       	mov	r31, r0
     ad4:	03 c0       	rjmp	.+6      	; 0xadc <disk_initialize+0x16c>
			} else {
				ty = CT_MMC; cmd = CMD1;	// MMCv3 
			}
			for (tmr = 25000; tmr && send_cmd(cmd, 0); tmr--) ;	// Wait for leaving idle state 
			if (!tmr || send_cmd(CMD16, 512) != 0)			// Set R/W block length to 512 
				ty = 0;
     ad6:	f1 2c       	mov	r15, r1
     ad8:	01 c0       	rjmp	.+2      	; 0xadc <disk_initialize+0x16c>
     ada:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
     adc:	f0 92 f0 00 	sts	0x00F0, r15	; 0x8000f0 <CardType>
// Deselect the card and release SPI bus                                 
//-----------------------------------------------------------------------
static
void release_spi (void)
{
	rcv_spi();
     ae0:	0e 94 8a 03 	call	0x714	; 0x714 <rcv_spi>
//   	sprintf(str,"%d",CardType);
//   	setpos(0,1);
//   	str_lcd(str);
	release_spi();

	return ty ? 0 : STA_NOINIT;
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	ff 20       	and	r15, r15
     ae8:	21 f0       	breq	.+8      	; 0xaf2 <disk_initialize+0x182>
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	02 c0       	rjmp	.+4      	; 0xaf2 <disk_initialize+0x182>

//--------------------------------------------------------------------------
// Initialize Disk Drive                                                 
//--------------------------------------------------------------------------
DSTATUS disk_initialize (void)
{
     aee:	14 e6       	ldi	r17, 0x64	; 100
     af0:	59 cf       	rjmp	.-334    	; 0x9a4 <disk_initialize+0x34>
//   	setpos(0,1);
//   	str_lcd(str);
	release_spi();

	return ty ? 0 : STA_NOINIT;
}
     af2:	0f 90       	pop	r0
     af4:	0f 90       	pop	r0
     af6:	0f 90       	pop	r0
     af8:	0f 90       	pop	r0
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	ef 90       	pop	r14
     b06:	df 90       	pop	r13
     b08:	cf 90       	pop	r12
     b0a:	08 95       	ret

00000b0c <clust2sect>:

static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
     b0c:	0f 93       	push	r16
     b0e:	1f 93       	push	r17
	FATFS *fs = FatFs;
     b10:	e0 91 f1 00 	lds	r30, 0x00F1	; 0x8000f1 <FatFs>
     b14:	f0 91 f2 00 	lds	r31, 0x00F2	; 0x8000f2 <FatFs+0x1>


	clst -= 2;
     b18:	9b 01       	movw	r18, r22
     b1a:	ac 01       	movw	r20, r24
     b1c:	22 50       	subi	r18, 0x02	; 2
     b1e:	31 09       	sbc	r19, r1
     b20:	41 09       	sbc	r20, r1
     b22:	51 09       	sbc	r21, r1
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     b24:	80 85       	ldd	r24, Z+8	; 0x08
     b26:	91 85       	ldd	r25, Z+9	; 0x09
     b28:	a2 85       	ldd	r26, Z+10	; 0x0a
     b2a:	b3 85       	ldd	r27, Z+11	; 0x0b
     b2c:	02 97       	sbiw	r24, 0x02	; 2
     b2e:	a1 09       	sbc	r26, r1
     b30:	b1 09       	sbc	r27, r1
     b32:	28 17       	cp	r18, r24
     b34:	39 07       	cpc	r19, r25
     b36:	4a 07       	cpc	r20, r26
     b38:	5b 07       	cpc	r21, r27
     b3a:	68 f4       	brcc	.+26     	; 0xb56 <clust2sect+0x4a>
	return (DWORD)clst * fs->csize + fs->database;
     b3c:	a1 81       	ldd	r26, Z+1	; 0x01
     b3e:	b0 e0       	ldi	r27, 0x00	; 0
     b40:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <__muluhisi3>
     b44:	04 89       	ldd	r16, Z+20	; 0x14
     b46:	15 89       	ldd	r17, Z+21	; 0x15
     b48:	26 89       	ldd	r18, Z+22	; 0x16
     b4a:	37 89       	ldd	r19, Z+23	; 0x17
     b4c:	60 0f       	add	r22, r16
     b4e:	71 1f       	adc	r23, r17
     b50:	82 1f       	adc	r24, r18
     b52:	93 1f       	adc	r25, r19
     b54:	03 c0       	rjmp	.+6      	; 0xb5c <clust2sect+0x50>
{
	FATFS *fs = FatFs;


	clst -= 2;
	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
     b56:	60 e0       	ldi	r22, 0x00	; 0
     b58:	70 e0       	ldi	r23, 0x00	; 0
     b5a:	cb 01       	movw	r24, r22
	return (DWORD)clst * fs->csize + fs->database;
}
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	08 95       	ret

00000b62 <dir_rewind>:

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	fc 01       	movw	r30, r24
	CLUST clst;
	FATFS *fs = FatFs;
     b6c:	a0 91 f1 00 	lds	r26, 0x00F1	; 0x8000f1 <FatFs>
     b70:	b0 91 f2 00 	lds	r27, 0x00F2	; 0x8000f2 <FatFs+0x1>


	dj->index = 0;
     b74:	11 82       	std	Z+1, r1	; 0x01
     b76:	10 82       	st	Z, r1
	clst = dj->sclust;
     b78:	64 81       	ldd	r22, Z+4	; 0x04
     b7a:	75 81       	ldd	r23, Z+5	; 0x05
     b7c:	86 81       	ldd	r24, Z+6	; 0x06
     b7e:	97 81       	ldd	r25, Z+7	; 0x07
	if (clst == 1 || clst >= fs->max_clust)	/* Check start cluster range */
     b80:	61 30       	cpi	r22, 0x01	; 1
     b82:	71 05       	cpc	r23, r1
     b84:	81 05       	cpc	r24, r1
     b86:	91 05       	cpc	r25, r1
     b88:	91 f1       	breq	.+100    	; 0xbee <dir_rewind+0x8c>
     b8a:	18 96       	adiw	r26, 0x08	; 8
     b8c:	0d 91       	ld	r16, X+
     b8e:	1d 91       	ld	r17, X+
     b90:	2d 91       	ld	r18, X+
     b92:	3c 91       	ld	r19, X
     b94:	1b 97       	sbiw	r26, 0x0b	; 11
     b96:	60 17       	cp	r22, r16
     b98:	71 07       	cpc	r23, r17
     b9a:	82 07       	cpc	r24, r18
     b9c:	93 07       	cpc	r25, r19
     b9e:	48 f5       	brcc	.+82     	; 0xbf2 <dir_rewind+0x90>
     ba0:	ef 01       	movw	r28, r30
		return FR_DISK_ERR;
#if _FS_FAT32
	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
     ba2:	61 15       	cp	r22, r1
     ba4:	71 05       	cpc	r23, r1
     ba6:	81 05       	cpc	r24, r1
     ba8:	91 05       	cpc	r25, r1
     baa:	29 f5       	brne	.+74     	; 0xbf6 <dir_rewind+0x94>
     bac:	8c 91       	ld	r24, X
     bae:	83 30       	cpi	r24, 0x03	; 3
     bb0:	39 f5       	brne	.+78     	; 0xc00 <dir_rewind+0x9e>
		clst = fs->dirbase;
     bb2:	50 96       	adiw	r26, 0x10	; 16
     bb4:	6d 91       	ld	r22, X+
     bb6:	7d 91       	ld	r23, X+
     bb8:	8d 91       	ld	r24, X+
     bba:	9c 91       	ld	r25, X
     bbc:	53 97       	sbiw	r26, 0x13	; 19
#endif
	dj->clust = clst;						/* Current cluster */
     bbe:	60 87       	std	Z+8, r22	; 0x08
     bc0:	71 87       	std	Z+9, r23	; 0x09
     bc2:	82 87       	std	Z+10, r24	; 0x0a
     bc4:	93 87       	std	Z+11, r25	; 0x0b
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
     bc6:	61 15       	cp	r22, r1
     bc8:	71 05       	cpc	r23, r1
     bca:	81 05       	cpc	r24, r1
     bcc:	91 05       	cpc	r25, r1
     bce:	19 f0       	breq	.+6      	; 0xbd6 <dir_rewind+0x74>
     bd0:	0e 94 86 05 	call	0xb0c	; 0xb0c <clust2sect>
     bd4:	06 c0       	rjmp	.+12     	; 0xbe2 <dir_rewind+0x80>
     bd6:	50 96       	adiw	r26, 0x10	; 16
     bd8:	6d 91       	ld	r22, X+
     bda:	7d 91       	ld	r23, X+
     bdc:	8d 91       	ld	r24, X+
     bde:	9c 91       	ld	r25, X
     be0:	53 97       	sbiw	r26, 0x13	; 19
     be2:	6c 87       	std	Y+12, r22	; 0x0c
     be4:	7d 87       	std	Y+13, r23	; 0x0d
     be6:	8e 87       	std	Y+14, r24	; 0x0e
     be8:	9f 87       	std	Y+15, r25	; 0x0f

	return FR_OK;	/* Seek succeeded */
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	0e c0       	rjmp	.+28     	; 0xc0a <dir_rewind+0xa8>


	dj->index = 0;
	clst = dj->sclust;
	if (clst == 1 || clst >= fs->max_clust)	/* Check start cluster range */
		return FR_DISK_ERR;
     bee:	81 e0       	ldi	r24, 0x01	; 1
     bf0:	0c c0       	rjmp	.+24     	; 0xc0a <dir_rewind+0xa8>
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	0a c0       	rjmp	.+20     	; 0xc0a <dir_rewind+0xa8>
#if _FS_FAT32
	if (!clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = fs->dirbase;
#endif
	dj->clust = clst;						/* Current cluster */
     bf6:	60 87       	std	Z+8, r22	; 0x08
     bf8:	71 87       	std	Z+9, r23	; 0x09
     bfa:	82 87       	std	Z+10, r24	; 0x0a
     bfc:	93 87       	std	Z+11, r25	; 0x0b
     bfe:	e8 cf       	rjmp	.-48     	; 0xbd0 <dir_rewind+0x6e>
     c00:	10 86       	std	Z+8, r1	; 0x08
     c02:	11 86       	std	Z+9, r1	; 0x09
     c04:	12 86       	std	Z+10, r1	; 0x0a
     c06:	13 86       	std	Z+11, r1	; 0x0b
     c08:	e6 cf       	rjmp	.-52     	; 0xbd6 <dir_rewind+0x74>
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */

	return FR_OK;	/* Seek succeeded */
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	08 95       	ret

00000c14 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
     c14:	cf 92       	push	r12
     c16:	df 92       	push	r13
     c18:	ef 92       	push	r14
     c1a:	ff 92       	push	r15
     c1c:	0f 93       	push	r16
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
     c24:	ec 01       	movw	r28, r24
     c26:	6a 01       	movw	r12, r20
     c28:	7b 01       	movw	r14, r22
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
     c2a:	02 e0       	ldi	r16, 0x02	; 2
     c2c:	10 e0       	ldi	r17, 0x00	; 0
     c2e:	2e ef       	ldi	r18, 0xFE	; 254
     c30:	31 e0       	ldi	r19, 0x01	; 1
     c32:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     c36:	81 11       	cpse	r24, r1
     c38:	26 c0       	rjmp	.+76     	; 0xc86 <check_fs+0x72>
		return 3;

	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
     c3a:	88 81       	ld	r24, Y
     c3c:	99 81       	ldd	r25, Y+1	; 0x01
     c3e:	85 35       	cpi	r24, 0x55	; 85
     c40:	9a 4a       	sbci	r25, 0xAA	; 170
     c42:	19 f5       	brne	.+70     	; 0xc8a <check_fs+0x76>
		return 2;

	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
     c44:	26 e3       	ldi	r18, 0x36	; 54
     c46:	30 e0       	ldi	r19, 0x00	; 0
     c48:	b7 01       	movw	r22, r14
     c4a:	a6 01       	movw	r20, r12
     c4c:	ce 01       	movw	r24, r28
     c4e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     c52:	81 11       	cpse	r24, r1
     c54:	05 c0       	rjmp	.+10     	; 0xc60 <check_fs+0x4c>
     c56:	88 81       	ld	r24, Y
     c58:	99 81       	ldd	r25, Y+1	; 0x01
     c5a:	86 34       	cpi	r24, 0x46	; 70
     c5c:	91 44       	sbci	r25, 0x41	; 65
     c5e:	b9 f0       	breq	.+46     	; 0xc8e <check_fs+0x7a>
		return 0;
#if _FS_FAT32
	if (!disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
     c60:	02 e0       	ldi	r16, 0x02	; 2
     c62:	10 e0       	ldi	r17, 0x00	; 0
     c64:	22 e5       	ldi	r18, 0x52	; 82
     c66:	30 e0       	ldi	r19, 0x00	; 0
     c68:	b7 01       	movw	r22, r14
     c6a:	a6 01       	movw	r20, r12
     c6c:	ce 01       	movw	r24, r28
     c6e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     c72:	81 11       	cpse	r24, r1
     c74:	0e c0       	rjmp	.+28     	; 0xc92 <check_fs+0x7e>
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	28 81       	ld	r18, Y
     c7a:	39 81       	ldd	r19, Y+1	; 0x01
     c7c:	26 34       	cpi	r18, 0x46	; 70
     c7e:	31 44       	sbci	r19, 0x41	; 65
     c80:	49 f4       	brne	.+18     	; 0xc94 <check_fs+0x80>
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	07 c0       	rjmp	.+14     	; 0xc94 <check_fs+0x80>
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
		return 3;
     c86:	83 e0       	ldi	r24, 0x03	; 3
     c88:	05 c0       	rjmp	.+10     	; 0xc94 <check_fs+0x80>

	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
		return 2;
     c8a:	82 e0       	ldi	r24, 0x02	; 2
     c8c:	03 c0       	rjmp	.+6      	; 0xc94 <check_fs+0x80>

	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
		return 0;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <check_fs+0x80>
#if _FS_FAT32
	if (!disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
		return 0;
#endif
	return 1;
     c92:	81 e0       	ldi	r24, 0x01	; 1
}
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	1f 91       	pop	r17
     c9a:	0f 91       	pop	r16
     c9c:	ff 90       	pop	r15
     c9e:	ef 90       	pop	r14
     ca0:	df 90       	pop	r13
     ca2:	cf 90       	pop	r12
     ca4:	08 95       	ret

00000ca6 <get_fat>:

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
     ca6:	4f 92       	push	r4
     ca8:	5f 92       	push	r5
     caa:	6f 92       	push	r6
     cac:	7f 92       	push	r7
     cae:	af 92       	push	r10
     cb0:	bf 92       	push	r11
     cb2:	cf 92       	push	r12
     cb4:	df 92       	push	r13
     cb6:	ef 92       	push	r14
     cb8:	ff 92       	push	r15
     cba:	0f 93       	push	r16
     cbc:	1f 93       	push	r17
     cbe:	cf 93       	push	r28
     cc0:	df 93       	push	r29
     cc2:	00 d0       	rcall	.+0      	; 0xcc4 <get_fat+0x1e>
     cc4:	00 d0       	rcall	.+0      	; 0xcc6 <get_fat+0x20>
     cc6:	cd b7       	in	r28, 0x3d	; 61
     cc8:	de b7       	in	r29, 0x3e	; 62
     cca:	6b 01       	movw	r12, r22
     ccc:	7c 01       	movw	r14, r24
	WORD wc, bc, ofs;
	BYTE buf[4];
	FATFS *fs = FatFs;
     cce:	a0 90 f1 00 	lds	r10, 0x00F1	; 0x8000f1 <FatFs>
     cd2:	b0 90 f2 00 	lds	r11, 0x00F2	; 0x8000f2 <FatFs+0x1>


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
     cd6:	82 e0       	ldi	r24, 0x02	; 2
     cd8:	c8 16       	cp	r12, r24
     cda:	d1 04       	cpc	r13, r1
     cdc:	e1 04       	cpc	r14, r1
     cde:	f1 04       	cpc	r15, r1
     ce0:	08 f4       	brcc	.+2      	; 0xce4 <get_fat+0x3e>
     ce2:	b6 c0       	rjmp	.+364    	; 0xe50 <get_fat+0x1aa>
     ce4:	f5 01       	movw	r30, r10
     ce6:	80 85       	ldd	r24, Z+8	; 0x08
     ce8:	91 85       	ldd	r25, Z+9	; 0x09
     cea:	a2 85       	ldd	r26, Z+10	; 0x0a
     cec:	b3 85       	ldd	r27, Z+11	; 0x0b
     cee:	c8 16       	cp	r12, r24
     cf0:	d9 06       	cpc	r13, r25
     cf2:	ea 06       	cpc	r14, r26
     cf4:	fb 06       	cpc	r15, r27
     cf6:	08 f0       	brcs	.+2      	; 0xcfa <get_fat+0x54>
     cf8:	b0 c0       	rjmp	.+352    	; 0xe5a <get_fat+0x1b4>
		return 1;

	switch (fs->fs_type) {
     cfa:	80 81       	ld	r24, Z
     cfc:	82 30       	cpi	r24, 0x02	; 2
     cfe:	09 f4       	brne	.+2      	; 0xd02 <get_fat+0x5c>
     d00:	61 c0       	rjmp	.+194    	; 0xdc4 <get_fat+0x11e>
     d02:	83 30       	cpi	r24, 0x03	; 3
     d04:	09 f4       	brne	.+2      	; 0xd08 <get_fat+0x62>
     d06:	7c c0       	rjmp	.+248    	; 0xe00 <get_fat+0x15a>
     d08:	81 30       	cpi	r24, 0x01	; 1
     d0a:	09 f0       	breq	.+2      	; 0xd0e <get_fat+0x68>
     d0c:	ab c0       	rjmp	.+342    	; 0xe64 <get_fat+0x1be>
	case FS_FAT12 :
		bc = (WORD)clst; bc += bc / 2;
     d0e:	26 01       	movw	r4, r12
     d10:	56 94       	lsr	r5
     d12:	47 94       	ror	r4
     d14:	4c 0c       	add	r4, r12
     d16:	5d 1c       	adc	r5, r13
		ofs = bc % 512; bc /= 512;
     d18:	92 01       	movw	r18, r4
     d1a:	31 70       	andi	r19, 0x01	; 1
     d1c:	45 2c       	mov	r4, r5
     d1e:	55 24       	eor	r5, r5
     d20:	46 94       	lsr	r4
		if (ofs != 511) {
     d22:	2f 3f       	cpi	r18, 0xFF	; 255
     d24:	f1 e0       	ldi	r31, 0x01	; 1
     d26:	3f 07       	cpc	r19, r31
     d28:	91 f0       	breq	.+36     	; 0xd4e <get_fat+0xa8>
			if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
     d2a:	f5 01       	movw	r30, r10
     d2c:	44 85       	ldd	r20, Z+12	; 0x0c
     d2e:	55 85       	ldd	r21, Z+13	; 0x0d
     d30:	66 85       	ldd	r22, Z+14	; 0x0e
     d32:	77 85       	ldd	r23, Z+15	; 0x0f
     d34:	44 0d       	add	r20, r4
     d36:	55 1d       	adc	r21, r5
     d38:	61 1d       	adc	r22, r1
     d3a:	71 1d       	adc	r23, r1
     d3c:	02 e0       	ldi	r16, 0x02	; 2
     d3e:	10 e0       	ldi	r17, 0x00	; 0
     d40:	ce 01       	movw	r24, r28
     d42:	01 96       	adiw	r24, 0x01	; 1
     d44:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     d48:	88 23       	and	r24, r24
     d4a:	59 f1       	breq	.+86     	; 0xda2 <get_fat+0xfc>
     d4c:	90 c0       	rjmp	.+288    	; 0xe6e <get_fat+0x1c8>
		} else {
			if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
     d4e:	61 2c       	mov	r6, r1
     d50:	71 2c       	mov	r7, r1
     d52:	f5 01       	movw	r30, r10
     d54:	44 85       	ldd	r20, Z+12	; 0x0c
     d56:	55 85       	ldd	r21, Z+13	; 0x0d
     d58:	66 85       	ldd	r22, Z+14	; 0x0e
     d5a:	77 85       	ldd	r23, Z+15	; 0x0f
     d5c:	44 0d       	add	r20, r4
     d5e:	55 1d       	adc	r21, r5
     d60:	66 1d       	adc	r22, r6
     d62:	77 1d       	adc	r23, r7
     d64:	01 e0       	ldi	r16, 0x01	; 1
     d66:	10 e0       	ldi	r17, 0x00	; 0
     d68:	2f ef       	ldi	r18, 0xFF	; 255
     d6a:	31 e0       	ldi	r19, 0x01	; 1
     d6c:	ce 01       	movw	r24, r28
     d6e:	01 96       	adiw	r24, 0x01	; 1
     d70:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     d74:	81 11       	cpse	r24, r1
     d76:	80 c0       	rjmp	.+256    	; 0xe78 <get_fat+0x1d2>
     d78:	f5 01       	movw	r30, r10
     d7a:	44 85       	ldd	r20, Z+12	; 0x0c
     d7c:	55 85       	ldd	r21, Z+13	; 0x0d
     d7e:	66 85       	ldd	r22, Z+14	; 0x0e
     d80:	77 85       	ldd	r23, Z+15	; 0x0f
     d82:	4f 5f       	subi	r20, 0xFF	; 255
     d84:	5f 4f       	sbci	r21, 0xFF	; 255
     d86:	6f 4f       	sbci	r22, 0xFF	; 255
     d88:	7f 4f       	sbci	r23, 0xFF	; 255
			if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
     d8a:	44 0d       	add	r20, r4
     d8c:	55 1d       	adc	r21, r5
     d8e:	66 1d       	adc	r22, r6
     d90:	77 1d       	adc	r23, r7
     d92:	20 e0       	ldi	r18, 0x00	; 0
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	ce 01       	movw	r24, r28
     d98:	02 96       	adiw	r24, 0x02	; 2
     d9a:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     d9e:	81 11       	cpse	r24, r1
     da0:	70 c0       	rjmp	.+224    	; 0xe82 <get_fat+0x1dc>
		}
		wc = LD_WORD(buf);
     da2:	69 81       	ldd	r22, Y+1	; 0x01
     da4:	7a 81       	ldd	r23, Y+2	; 0x02
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
     da6:	c0 fe       	sbrs	r12, 0
     da8:	09 c0       	rjmp	.+18     	; 0xdbc <get_fat+0x116>
     daa:	72 95       	swap	r23
     dac:	62 95       	swap	r22
     dae:	6f 70       	andi	r22, 0x0F	; 15
     db0:	67 27       	eor	r22, r23
     db2:	7f 70       	andi	r23, 0x0F	; 15
     db4:	67 27       	eor	r22, r23
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	90 e0       	ldi	r25, 0x00	; 0
     dba:	71 c0       	rjmp	.+226    	; 0xe9e <get_fat+0x1f8>
     dbc:	7f 70       	andi	r23, 0x0F	; 15
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	6d c0       	rjmp	.+218    	; 0xe9e <get_fat+0x1f8>

	case FS_FAT16 :
		if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
     dc4:	96 01       	movw	r18, r12
     dc6:	33 27       	eor	r19, r19
     dc8:	22 0f       	add	r18, r18
     dca:	33 1f       	adc	r19, r19
     dcc:	77 27       	eor	r23, r23
     dce:	6f 2d       	mov	r22, r15
     dd0:	5e 2d       	mov	r21, r14
     dd2:	4d 2d       	mov	r20, r13
     dd4:	f5 01       	movw	r30, r10
     dd6:	84 85       	ldd	r24, Z+12	; 0x0c
     dd8:	95 85       	ldd	r25, Z+13	; 0x0d
     dda:	a6 85       	ldd	r26, Z+14	; 0x0e
     ddc:	b7 85       	ldd	r27, Z+15	; 0x0f
     dde:	48 0f       	add	r20, r24
     de0:	59 1f       	adc	r21, r25
     de2:	6a 1f       	adc	r22, r26
     de4:	7b 1f       	adc	r23, r27
     de6:	02 e0       	ldi	r16, 0x02	; 2
     de8:	10 e0       	ldi	r17, 0x00	; 0
     dea:	ce 01       	movw	r24, r28
     dec:	01 96       	adiw	r24, 0x01	; 1
     dee:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     df2:	81 11       	cpse	r24, r1
     df4:	4b c0       	rjmp	.+150    	; 0xe8c <get_fat+0x1e6>
		return LD_WORD(buf);
     df6:	69 81       	ldd	r22, Y+1	; 0x01
     df8:	7a 81       	ldd	r23, Y+2	; 0x02
     dfa:	80 e0       	ldi	r24, 0x00	; 0
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	4f c0       	rjmp	.+158    	; 0xe9e <get_fat+0x1f8>
#if _FS_FAT32
	case FS_FAT32 :
		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
     e00:	96 01       	movw	r18, r12
     e02:	2f 77       	andi	r18, 0x7F	; 127
     e04:	33 27       	eor	r19, r19
     e06:	22 0f       	add	r18, r18
     e08:	33 1f       	adc	r19, r19
     e0a:	22 0f       	add	r18, r18
     e0c:	33 1f       	adc	r19, r19
     e0e:	68 94       	set
     e10:	16 f8       	bld	r1, 6
     e12:	f6 94       	lsr	r15
     e14:	e7 94       	ror	r14
     e16:	d7 94       	ror	r13
     e18:	c7 94       	ror	r12
     e1a:	16 94       	lsr	r1
     e1c:	d1 f7       	brne	.-12     	; 0xe12 <get_fat+0x16c>
     e1e:	f5 01       	movw	r30, r10
     e20:	44 85       	ldd	r20, Z+12	; 0x0c
     e22:	55 85       	ldd	r21, Z+13	; 0x0d
     e24:	66 85       	ldd	r22, Z+14	; 0x0e
     e26:	77 85       	ldd	r23, Z+15	; 0x0f
     e28:	4c 0d       	add	r20, r12
     e2a:	5d 1d       	adc	r21, r13
     e2c:	6e 1d       	adc	r22, r14
     e2e:	7f 1d       	adc	r23, r15
     e30:	04 e0       	ldi	r16, 0x04	; 4
     e32:	10 e0       	ldi	r17, 0x00	; 0
     e34:	ce 01       	movw	r24, r28
     e36:	01 96       	adiw	r24, 0x01	; 1
     e38:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
     e3c:	81 11       	cpse	r24, r1
     e3e:	2b c0       	rjmp	.+86     	; 0xe96 <get_fat+0x1f0>
		return LD_DWORD(buf) & 0x0FFFFFFF;
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	9a 81       	ldd	r25, Y+2	; 0x02
     e44:	ab 81       	ldd	r26, Y+3	; 0x03
     e46:	bc 81       	ldd	r27, Y+4	; 0x04
     e48:	bc 01       	movw	r22, r24
     e4a:	cd 01       	movw	r24, r26
     e4c:	9f 70       	andi	r25, 0x0F	; 15
     e4e:	27 c0       	rjmp	.+78     	; 0xe9e <get_fat+0x1f8>
	BYTE buf[4];
	FATFS *fs = FatFs;


	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
		return 1;
     e50:	61 e0       	ldi	r22, 0x01	; 1
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	22 c0       	rjmp	.+68     	; 0xe9e <get_fat+0x1f8>
     e5a:	61 e0       	ldi	r22, 0x01	; 1
     e5c:	70 e0       	ldi	r23, 0x00	; 0
     e5e:	80 e0       	ldi	r24, 0x00	; 0
     e60:	90 e0       	ldi	r25, 0x00	; 0
     e62:	1d c0       	rjmp	.+58     	; 0xe9e <get_fat+0x1f8>
		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
		return LD_DWORD(buf) & 0x0FFFFFFF;
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
     e64:	61 e0       	ldi	r22, 0x01	; 1
     e66:	70 e0       	ldi	r23, 0x00	; 0
     e68:	80 e0       	ldi	r24, 0x00	; 0
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	18 c0       	rjmp	.+48     	; 0xe9e <get_fat+0x1f8>
     e6e:	61 e0       	ldi	r22, 0x01	; 1
     e70:	70 e0       	ldi	r23, 0x00	; 0
     e72:	80 e0       	ldi	r24, 0x00	; 0
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	13 c0       	rjmp	.+38     	; 0xe9e <get_fat+0x1f8>
     e78:	61 e0       	ldi	r22, 0x01	; 1
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	0e c0       	rjmp	.+28     	; 0xe9e <get_fat+0x1f8>
     e82:	61 e0       	ldi	r22, 0x01	; 1
     e84:	70 e0       	ldi	r23, 0x00	; 0
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	09 c0       	rjmp	.+18     	; 0xe9e <get_fat+0x1f8>
     e8c:	61 e0       	ldi	r22, 0x01	; 1
     e8e:	70 e0       	ldi	r23, 0x00	; 0
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	04 c0       	rjmp	.+8      	; 0xe9e <get_fat+0x1f8>
     e96:	61 e0       	ldi	r22, 0x01	; 1
     e98:	70 e0       	ldi	r23, 0x00	; 0
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	90 e0       	ldi	r25, 0x00	; 0
}
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	0f 90       	pop	r0
     ea6:	df 91       	pop	r29
     ea8:	cf 91       	pop	r28
     eaa:	1f 91       	pop	r17
     eac:	0f 91       	pop	r16
     eae:	ff 90       	pop	r15
     eb0:	ef 90       	pop	r14
     eb2:	df 90       	pop	r13
     eb4:	cf 90       	pop	r12
     eb6:	bf 90       	pop	r11
     eb8:	af 90       	pop	r10
     eba:	7f 90       	pop	r7
     ebc:	6f 90       	pop	r6
     ebe:	5f 90       	pop	r5
     ec0:	4f 90       	pop	r4
     ec2:	08 95       	ret

00000ec4 <dir_next>:

static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table */
	DIR *dj			/* Pointer to directory object */
)
{
     ec4:	cf 92       	push	r12
     ec6:	df 92       	push	r13
     ec8:	ef 92       	push	r14
     eca:	ff 92       	push	r15
     ecc:	0f 93       	push	r16
     ece:	1f 93       	push	r17
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;
     ed4:	e0 90 f1 00 	lds	r14, 0x00F1	; 0x8000f1 <FatFs>
     ed8:	f0 90 f2 00 	lds	r15, 0x00F2	; 0x8000f2 <FatFs+0x1>


	i = dj->index + 1;
     edc:	fc 01       	movw	r30, r24
     ede:	c0 81       	ld	r28, Z
     ee0:	d1 81       	ldd	r29, Z+1	; 0x01
     ee2:	21 96       	adiw	r28, 0x01	; 1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
     ee4:	09 f4       	brne	.+2      	; 0xee8 <dir_next+0x24>
     ee6:	5c c0       	rjmp	.+184    	; 0xfa0 <dir_next+0xdc>
     ee8:	44 85       	ldd	r20, Z+12	; 0x0c
     eea:	55 85       	ldd	r21, Z+13	; 0x0d
     eec:	66 85       	ldd	r22, Z+14	; 0x0e
     eee:	77 85       	ldd	r23, Z+15	; 0x0f
     ef0:	41 15       	cp	r20, r1
     ef2:	51 05       	cpc	r21, r1
     ef4:	61 05       	cpc	r22, r1
     ef6:	71 05       	cpc	r23, r1
     ef8:	09 f4       	brne	.+2      	; 0xefc <dir_next+0x38>
     efa:	54 c0       	rjmp	.+168    	; 0xfa4 <dir_next+0xe0>
     efc:	8c 01       	movw	r16, r24
		return FR_NO_FILE;

	if (!(i & (16-1))) {	/* Sector changed? */
     efe:	ce 01       	movw	r24, r28
     f00:	8f 70       	andi	r24, 0x0F	; 15
     f02:	99 27       	eor	r25, r25
     f04:	89 2b       	or	r24, r25
     f06:	09 f0       	breq	.+2      	; 0xf0a <dir_next+0x46>
     f08:	46 c0       	rjmp	.+140    	; 0xf96 <dir_next+0xd2>
		dj->sect++;			/* Next sector */
     f0a:	4f 5f       	subi	r20, 0xFF	; 255
     f0c:	5f 4f       	sbci	r21, 0xFF	; 255
     f0e:	6f 4f       	sbci	r22, 0xFF	; 255
     f10:	7f 4f       	sbci	r23, 0xFF	; 255
     f12:	44 87       	std	Z+12, r20	; 0x0c
     f14:	55 87       	std	Z+13, r21	; 0x0d
     f16:	66 87       	std	Z+14, r22	; 0x0e
     f18:	77 87       	std	Z+15, r23	; 0x0f

		if (dj->clust == 0) {	/* Static table */
     f1a:	40 85       	ldd	r20, Z+8	; 0x08
     f1c:	51 85       	ldd	r21, Z+9	; 0x09
     f1e:	62 85       	ldd	r22, Z+10	; 0x0a
     f20:	73 85       	ldd	r23, Z+11	; 0x0b
     f22:	41 15       	cp	r20, r1
     f24:	51 05       	cpc	r21, r1
     f26:	61 05       	cpc	r22, r1
     f28:	71 05       	cpc	r23, r1
     f2a:	39 f4       	brne	.+14     	; 0xf3a <dir_next+0x76>
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
     f2c:	f7 01       	movw	r30, r14
     f2e:	84 81       	ldd	r24, Z+4	; 0x04
     f30:	95 81       	ldd	r25, Z+5	; 0x05
     f32:	c8 17       	cp	r28, r24
     f34:	d9 07       	cpc	r29, r25
     f36:	c0 f5       	brcc	.+112    	; 0xfa8 <dir_next+0xe4>
     f38:	2e c0       	rjmp	.+92     	; 0xf96 <dir_next+0xd2>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
     f3a:	f7 01       	movw	r30, r14
     f3c:	81 81       	ldd	r24, Z+1	; 0x01
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	01 97       	sbiw	r24, 0x01	; 1
     f42:	9e 01       	movw	r18, r28
     f44:	32 95       	swap	r19
     f46:	22 95       	swap	r18
     f48:	2f 70       	andi	r18, 0x0F	; 15
     f4a:	23 27       	eor	r18, r19
     f4c:	3f 70       	andi	r19, 0x0F	; 15
     f4e:	23 27       	eor	r18, r19
     f50:	82 23       	and	r24, r18
     f52:	93 23       	and	r25, r19
     f54:	89 2b       	or	r24, r25
     f56:	f9 f4       	brne	.+62     	; 0xf96 <dir_next+0xd2>
				clst = get_fat(dj->clust);		/* Get next cluster */
     f58:	cb 01       	movw	r24, r22
     f5a:	ba 01       	movw	r22, r20
     f5c:	0e 94 53 06 	call	0xca6	; 0xca6 <get_fat>
				if (clst <= 1) return FR_DISK_ERR;
     f60:	62 30       	cpi	r22, 0x02	; 2
     f62:	71 05       	cpc	r23, r1
     f64:	81 05       	cpc	r24, r1
     f66:	91 05       	cpc	r25, r1
     f68:	08 f1       	brcs	.+66     	; 0xfac <dir_next+0xe8>
				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
     f6a:	f7 01       	movw	r30, r14
     f6c:	c0 84       	ldd	r12, Z+8	; 0x08
     f6e:	d1 84       	ldd	r13, Z+9	; 0x09
     f70:	e2 84       	ldd	r14, Z+10	; 0x0a
     f72:	f3 84       	ldd	r15, Z+11	; 0x0b
     f74:	6c 15       	cp	r22, r12
     f76:	7d 05       	cpc	r23, r13
     f78:	8e 05       	cpc	r24, r14
     f7a:	9f 05       	cpc	r25, r15
     f7c:	c8 f4       	brcc	.+50     	; 0xfb0 <dir_next+0xec>
					return FR_NO_FILE;			/* Report EOT */
				dj->clust = clst;				/* Initialize data for new cluster */
     f7e:	f8 01       	movw	r30, r16
     f80:	60 87       	std	Z+8, r22	; 0x08
     f82:	71 87       	std	Z+9, r23	; 0x09
     f84:	82 87       	std	Z+10, r24	; 0x0a
     f86:	93 87       	std	Z+11, r25	; 0x0b
				dj->sect = clust2sect(clst);
     f88:	0e 94 86 05 	call	0xb0c	; 0xb0c <clust2sect>
     f8c:	f8 01       	movw	r30, r16
     f8e:	64 87       	std	Z+12, r22	; 0x0c
     f90:	75 87       	std	Z+13, r23	; 0x0d
     f92:	86 87       	std	Z+14, r24	; 0x0e
     f94:	97 87       	std	Z+15, r25	; 0x0f
			}
		}
	}

	dj->index = i;
     f96:	f8 01       	movw	r30, r16
     f98:	d1 83       	std	Z+1, r29	; 0x01
     f9a:	c0 83       	st	Z, r28

	return FR_OK;
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	09 c0       	rjmp	.+18     	; 0xfb2 <dir_next+0xee>
	FATFS *fs = FatFs;


	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;
     fa0:	83 e0       	ldi	r24, 0x03	; 3
     fa2:	07 c0       	rjmp	.+14     	; 0xfb2 <dir_next+0xee>
     fa4:	83 e0       	ldi	r24, 0x03	; 3
     fa6:	05 c0       	rjmp	.+10     	; 0xfb2 <dir_next+0xee>
	if (!(i & (16-1))) {	/* Sector changed? */
		dj->sect++;			/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
     fa8:	83 e0       	ldi	r24, 0x03	; 3
     faa:	03 c0       	rjmp	.+6      	; 0xfb2 <dir_next+0xee>
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->clust);		/* Get next cluster */
				if (clst <= 1) return FR_DISK_ERR;
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	01 c0       	rjmp	.+2      	; 0xfb2 <dir_next+0xee>
				if (clst >= fs->max_clust)		/* When it reached end of dynamic table */
					return FR_NO_FILE;			/* Report EOT */
     fb0:	83 e0       	ldi	r24, 0x03	; 3
	}

	dj->index = i;

	return FR_OK;
}
     fb2:	df 91       	pop	r29
     fb4:	cf 91       	pop	r28
     fb6:	1f 91       	pop	r17
     fb8:	0f 91       	pop	r16
     fba:	ff 90       	pop	r15
     fbc:	ef 90       	pop	r14
     fbe:	df 90       	pop	r13
     fc0:	cf 90       	pop	r12
     fc2:	08 95       	ret

00000fc4 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const char *path	/* Full-path string to find a file or directory */
)
{
     fc4:	2f 92       	push	r2
     fc6:	3f 92       	push	r3
     fc8:	4f 92       	push	r4
     fca:	5f 92       	push	r5
     fcc:	6f 92       	push	r6
     fce:	7f 92       	push	r7
     fd0:	8f 92       	push	r8
     fd2:	9f 92       	push	r9
     fd4:	af 92       	push	r10
     fd6:	bf 92       	push	r11
     fd8:	cf 92       	push	r12
     fda:	df 92       	push	r13
     fdc:	ef 92       	push	r14
     fde:	ff 92       	push	r15
     fe0:	0f 93       	push	r16
     fe2:	1f 93       	push	r17
     fe4:	cf 93       	push	r28
     fe6:	df 93       	push	r29
     fe8:	7c 01       	movw	r14, r24
     fea:	5b 01       	movw	r10, r22
	FRESULT res;
	BYTE *dir;


	while (*path == ' ') path++;		/* Skip leading spaces */
     fec:	db 01       	movw	r26, r22
     fee:	8c 91       	ld	r24, X
     ff0:	80 32       	cpi	r24, 0x20	; 32
     ff2:	31 f4       	brne	.+12     	; 0x1000 <follow_path+0x3c>
     ff4:	fb 01       	movw	r30, r22
     ff6:	31 96       	adiw	r30, 0x01	; 1
     ff8:	5f 01       	movw	r10, r30
     ffa:	81 91       	ld	r24, Z+
     ffc:	80 32       	cpi	r24, 0x20	; 32
     ffe:	e1 f3       	breq	.-8      	; 0xff8 <follow_path+0x34>
	if (*path == '/') path++;			/* Strip heading separator */
    1000:	8f 32       	cpi	r24, 0x2F	; 47
    1002:	19 f4       	brne	.+6      	; 0x100a <follow_path+0x46>
    1004:	bf ef       	ldi	r27, 0xFF	; 255
    1006:	ab 1a       	sub	r10, r27
    1008:	bb 0a       	sbc	r11, r27
	dj->sclust = 0;						/* Set start directory (always root dir) */
    100a:	f7 01       	movw	r30, r14
    100c:	14 82       	std	Z+4, r1	; 0x04
    100e:	15 82       	std	Z+5, r1	; 0x05
    1010:	16 82       	std	Z+6, r1	; 0x06
    1012:	17 82       	std	Z+7, r1	; 0x07

	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
    1014:	d5 01       	movw	r26, r10
    1016:	8c 91       	ld	r24, X
    1018:	81 32       	cpi	r24, 0x21	; 33
    101a:	68 f4       	brcc	.+26     	; 0x1036 <follow_path+0x72>
		res = dir_rewind(dj);
    101c:	c7 01       	movw	r24, r14
    101e:	0e 94 b1 05 	call	0xb62	; 0xb62 <dir_rewind>
    1022:	58 2f       	mov	r21, r24
		FatFs->buf[0] = 0;
    1024:	e0 91 f1 00 	lds	r30, 0x00F1	; 0x8000f1 <FatFs>
    1028:	f0 91 f2 00 	lds	r31, 0x00F2	; 0x8000f2 <FatFs+0x1>
    102c:	06 80       	ldd	r0, Z+6	; 0x06
    102e:	f7 81       	ldd	r31, Z+7	; 0x07
    1030:	e0 2d       	mov	r30, r0
    1032:	10 82       	st	Z, r1
    1034:	c3 c0       	rjmp	.+390    	; 0x11bc <follow_path+0x1f8>

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
    1036:	68 94       	set
    1038:	99 24       	eor	r9, r9
    103a:	95 f8       	bld	r9, 5
    103c:	61 2c       	mov	r6, r1
    103e:	68 94       	set
    1040:	44 24       	eor	r4, r4
    1042:	43 f8       	bld	r4, 3
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') break;
			i = 8; ni = 11;
    1044:	24 2c       	mov	r2, r4
    1046:	0f 2e       	mov	r0, r31
    1048:	fb e0       	ldi	r31, 0x0B	; 11
    104a:	3f 2e       	mov	r3, r31
    104c:	f0 2d       	mov	r31, r0
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
    104e:	55 24       	eor	r5, r5
    1050:	53 94       	inc	r5
	if (res != FR_OK) return res;

	dir = FatFs->buf;
	do {
		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
			? FR_DISK_ERR : FR_OK;
    1052:	85 2c       	mov	r8, r5
    1054:	76 2c       	mov	r7, r6
{
	BYTE c, d, ni, si, i, *sfn;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
    1056:	f7 01       	movw	r30, r14
    1058:	a2 81       	ldd	r26, Z+2	; 0x02
    105a:	b3 81       	ldd	r27, Z+3	; 0x03
    105c:	fd 01       	movw	r30, r26
    105e:	cd 01       	movw	r24, r26
    1060:	0b 96       	adiw	r24, 0x0b	; 11

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
    1062:	91 92       	st	Z+, r9
    1064:	e8 17       	cp	r30, r24
    1066:	f9 07       	cpc	r31, r25
    1068:	e1 f7       	brne	.-8      	; 0x1062 <follow_path+0x9e>
    106a:	96 2d       	mov	r25, r6
    106c:	86 2d       	mov	r24, r6
    106e:	34 2d       	mov	r19, r4
    1070:	01 c0       	rjmp	.+2      	; 0x1074 <follow_path+0xb0>
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
    1072:	82 2f       	mov	r24, r18
    1074:	21 e0       	ldi	r18, 0x01	; 1
    1076:	28 0f       	add	r18, r24
    1078:	f5 01       	movw	r30, r10
    107a:	e8 0f       	add	r30, r24
    107c:	f1 1d       	adc	r31, r1
    107e:	80 81       	ld	r24, Z
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
    1080:	81 32       	cpi	r24, 0x21	; 33
    1082:	90 f0       	brcs	.+36     	; 0x10a8 <follow_path+0xe4>
    1084:	8f 32       	cpi	r24, 0x2F	; 47
    1086:	81 f0       	breq	.+32     	; 0x10a8 <follow_path+0xe4>
		if (c == '.' || i >= ni) {
    1088:	8e 32       	cpi	r24, 0x2E	; 46
    108a:	09 f4       	brne	.+2      	; 0x108e <follow_path+0xca>
    108c:	8f c0       	rjmp	.+286    	; 0x11ac <follow_path+0x1e8>
    108e:	93 17       	cp	r25, r19
    1090:	58 f4       	brcc	.+22     	; 0x10a8 <follow_path+0xe4>
		if (IsDBCS1(c) && i >= ni - 1) {	/* DBC 1st byte? */
			d = p[si++];					/* Get 2nd byte */
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
    1092:	4f e9       	ldi	r20, 0x9F	; 159
    1094:	48 0f       	add	r20, r24
    1096:	4a 31       	cpi	r20, 0x1A	; 26
    1098:	08 f4       	brcc	.+2      	; 0x109c <follow_path+0xd8>
    109a:	80 52       	subi	r24, 0x20	; 32
			sfn[i++] = c;
    109c:	fd 01       	movw	r30, r26
    109e:	e9 0f       	add	r30, r25
    10a0:	f1 1d       	adc	r31, r1
    10a2:	80 83       	st	Z, r24
    10a4:	9f 5f       	subi	r25, 0xFF	; 255
    10a6:	e5 cf       	rjmp	.-54     	; 0x1072 <follow_path+0xae>
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */
    10a8:	a2 0e       	add	r10, r18
    10aa:	b1 1c       	adc	r11, r1

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
    10ac:	95 2d       	mov	r25, r5
    10ae:	81 32       	cpi	r24, 0x21	; 33
    10b0:	08 f0       	brcs	.+2      	; 0x10b4 <follow_path+0xf0>
    10b2:	96 2d       	mov	r25, r6
    10b4:	1b 96       	adiw	r26, 0x0b	; 11
    10b6:	9c 93       	st	X, r25
{
	FRESULT res;
	BYTE c, *dir;


	res = dir_rewind(dj);			/* Rewind directory object */
    10b8:	c7 01       	movw	r24, r14
    10ba:	0e 94 b1 05 	call	0xb62	; 0xb62 <dir_rewind>
    10be:	58 2f       	mov	r21, r24
	if (res != FR_OK) return res;
    10c0:	81 11       	cpse	r24, r1
    10c2:	7a c0       	rjmp	.+244    	; 0x11b8 <follow_path+0x1f4>

	dir = FatFs->buf;
    10c4:	e0 91 f1 00 	lds	r30, 0x00F1	; 0x8000f1 <FatFs>
    10c8:	f0 91 f2 00 	lds	r31, 0x00F2	; 0x8000f2 <FatFs+0x1>
    10cc:	c6 80       	ldd	r12, Z+6	; 0x06
    10ce:	d7 80       	ldd	r13, Z+7	; 0x07
    10d0:	e6 01       	movw	r28, r12
    10d2:	2b 96       	adiw	r28, 0x0b	; 11
	do {
		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
    10d4:	d7 01       	movw	r26, r14
    10d6:	2d 91       	ld	r18, X+
    10d8:	3c 91       	ld	r19, X
    10da:	11 97       	sbiw	r26, 0x01	; 1
    10dc:	2f 70       	andi	r18, 0x0F	; 15
    10de:	33 27       	eor	r19, r19
    10e0:	22 0f       	add	r18, r18
    10e2:	33 1f       	adc	r19, r19
    10e4:	22 95       	swap	r18
    10e6:	32 95       	swap	r19
    10e8:	30 7f       	andi	r19, 0xF0	; 240
    10ea:	32 27       	eor	r19, r18
    10ec:	20 7f       	andi	r18, 0xF0	; 240
    10ee:	32 27       	eor	r19, r18
    10f0:	1c 96       	adiw	r26, 0x0c	; 12
    10f2:	4d 91       	ld	r20, X+
    10f4:	5d 91       	ld	r21, X+
    10f6:	6d 91       	ld	r22, X+
    10f8:	7c 91       	ld	r23, X
    10fa:	1f 97       	sbiw	r26, 0x0f	; 15
    10fc:	00 e2       	ldi	r16, 0x20	; 32
    10fe:	10 e0       	ldi	r17, 0x00	; 0
    1100:	c6 01       	movw	r24, r12
    1102:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
			? FR_DISK_ERR : FR_OK;
    1106:	58 2d       	mov	r21, r8
    1108:	81 11       	cpse	r24, r1
    110a:	01 c0       	rjmp	.+2      	; 0x110e <follow_path+0x14a>
    110c:	57 2d       	mov	r21, r7
		if (res != FR_OK) break;
    110e:	51 11       	cpse	r21, r1
    1110:	53 c0       	rjmp	.+166    	; 0x11b8 <follow_path+0x1f4>
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    1112:	f6 01       	movw	r30, r12
    1114:	80 81       	ld	r24, Z
    1116:	88 23       	and	r24, r24
    1118:	c1 f0       	breq	.+48     	; 0x114a <follow_path+0x186>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    111a:	83 85       	ldd	r24, Z+11	; 0x0b
    111c:	83 fd       	sbrc	r24, 3
    111e:	0e c0       	rjmp	.+28     	; 0x113c <follow_path+0x178>
    1120:	d7 01       	movw	r26, r14
    1122:	12 96       	adiw	r26, 0x02	; 2
    1124:	2d 91       	ld	r18, X+
    1126:	3c 91       	ld	r19, X
    1128:	13 97       	sbiw	r26, 0x03	; 3
    112a:	d9 01       	movw	r26, r18
    112c:	03 c0       	rjmp	.+6      	; 0x1134 <follow_path+0x170>
/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
    112e:	ec 17       	cp	r30, r28
    1130:	fd 07       	cpc	r31, r29
    1132:	a9 f0       	breq	.+42     	; 0x115e <follow_path+0x19a>
    1134:	41 91       	ld	r20, Z+
    1136:	9d 91       	ld	r25, X+
    1138:	49 17       	cp	r20, r25
    113a:	c9 f3       	breq	.-14     	; 0x112e <follow_path+0x16a>
		if (res != FR_OK) break;
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
		res = dir_next(dj);							/* Next entry */
    113c:	c7 01       	movw	r24, r14
    113e:	0e 94 62 07 	call	0xec4	; 0xec4 <dir_next>
    1142:	58 2f       	mov	r21, r24
	} while (res == FR_OK);
    1144:	88 23       	and	r24, r24
    1146:	31 f2       	breq	.-116    	; 0x10d4 <follow_path+0x110>
    1148:	37 c0       	rjmp	.+110    	; 0x11b8 <follow_path+0x1f4>
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
    114a:	d7 01       	movw	r26, r14
    114c:	12 96       	adiw	r26, 0x02	; 2
    114e:	ed 91       	ld	r30, X+
    1150:	fc 91       	ld	r31, X
    1152:	13 97       	sbiw	r26, 0x03	; 3
    1154:	83 85       	ldd	r24, Z+11	; 0x0b
    1156:	88 23       	and	r24, r24
    1158:	29 f1       	breq	.+74     	; 0x11a4 <follow_path+0x1e0>

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
    115a:	53 e0       	ldi	r21, 0x03	; 3
    115c:	2f c0       	rjmp	.+94     	; 0x11bc <follow_path+0x1f8>
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
					res = FR_NO_PATH;
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
    115e:	f9 01       	movw	r30, r18
    1160:	83 85       	ldd	r24, Z+11	; 0x0b
    1162:	81 11       	cpse	r24, r1
    1164:	2b c0       	rjmp	.+86     	; 0x11bc <follow_path+0x1f8>
			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
    1166:	e0 91 f1 00 	lds	r30, 0x00F1	; 0x8000f1 <FatFs>
    116a:	f0 91 f2 00 	lds	r31, 0x00F2	; 0x8000f2 <FatFs+0x1>
    116e:	06 80       	ldd	r0, Z+6	; 0x06
    1170:	f7 81       	ldd	r31, Z+7	; 0x07
    1172:	e0 2d       	mov	r30, r0
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
    1174:	83 85       	ldd	r24, Z+11	; 0x0b
    1176:	84 ff       	sbrs	r24, 4
    1178:	17 c0       	rjmp	.+46     	; 0x11a8 <follow_path+0x1e4>
				res = FR_NO_PATH; break;
			}
			dj->sclust =
#if _FS_FAT32
				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | 
    117a:	84 89       	ldd	r24, Z+20	; 0x14
    117c:	95 89       	ldd	r25, Z+21	; 0x15
    117e:	a0 e0       	ldi	r26, 0x00	; 0
    1180:	b0 e0       	ldi	r27, 0x00	; 0
    1182:	dc 01       	movw	r26, r24
    1184:	99 27       	eor	r25, r25
    1186:	88 27       	eor	r24, r24
    1188:	42 8d       	ldd	r20, Z+26	; 0x1a
    118a:	53 8d       	ldd	r21, Z+27	; 0x1b
    118c:	60 e0       	ldi	r22, 0x00	; 0
    118e:	70 e0       	ldi	r23, 0x00	; 0
    1190:	84 2b       	or	r24, r20
    1192:	95 2b       	or	r25, r21
    1194:	a6 2b       	or	r26, r22
    1196:	b7 2b       	or	r27, r23
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust =
    1198:	f7 01       	movw	r30, r14
    119a:	84 83       	std	Z+4, r24	; 0x04
    119c:	95 83       	std	Z+5, r25	; 0x05
    119e:	a6 83       	std	Z+6, r26	; 0x06
    11a0:	b7 83       	std	Z+7, r27	; 0x07
#if _FS_FAT32
				((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | 
#endif
				LD_WORD(dir+DIR_FstClusLO);
		}
    11a2:	59 cf       	rjmp	.-334    	; 0x1056 <follow_path+0x92>
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
					res = FR_NO_PATH;
    11a4:	54 e0       	ldi	r21, 0x04	; 4
    11a6:	0a c0       	rjmp	.+20     	; 0x11bc <follow_path+0x1f8>
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			dir = FatFs->buf;				/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    11a8:	54 e0       	ldi	r21, 0x04	; 4
    11aa:	08 c0       	rjmp	.+16     	; 0x11bc <follow_path+0x1f8>
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') break;
    11ac:	38 30       	cpi	r19, 0x08	; 8
    11ae:	09 f0       	breq	.+2      	; 0x11b2 <follow_path+0x1ee>
    11b0:	7b cf       	rjmp	.-266    	; 0x10a8 <follow_path+0xe4>
			i = 8; ni = 11;
    11b2:	92 2d       	mov	r25, r2
    11b4:	33 2d       	mov	r19, r3
    11b6:	5d cf       	rjmp	.-326    	; 0x1072 <follow_path+0xae>
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
    11b8:	53 30       	cpi	r21, 0x03	; 3
    11ba:	39 f2       	breq	.-114    	; 0x114a <follow_path+0x186>
				LD_WORD(dir+DIR_FstClusLO);
		}
	}

	return res;
}
    11bc:	85 2f       	mov	r24, r21
    11be:	df 91       	pop	r29
    11c0:	cf 91       	pop	r28
    11c2:	1f 91       	pop	r17
    11c4:	0f 91       	pop	r16
    11c6:	ff 90       	pop	r15
    11c8:	ef 90       	pop	r14
    11ca:	df 90       	pop	r13
    11cc:	cf 90       	pop	r12
    11ce:	bf 90       	pop	r11
    11d0:	af 90       	pop	r10
    11d2:	9f 90       	pop	r9
    11d4:	8f 90       	pop	r8
    11d6:	7f 90       	pop	r7
    11d8:	6f 90       	pop	r6
    11da:	5f 90       	pop	r5
    11dc:	4f 90       	pop	r4
    11de:	3f 90       	pop	r3
    11e0:	2f 90       	pop	r2
    11e2:	08 95       	ret

000011e4 <pf_mount>:
/*-----------------------------------------------------------------------*/

FRESULT pf_mount (
	FATFS *fs		/* Pointer to new file system object (NULL: Unmount) */
)
{
    11e4:	4f 92       	push	r4
    11e6:	5f 92       	push	r5
    11e8:	6f 92       	push	r6
    11ea:	7f 92       	push	r7
    11ec:	8f 92       	push	r8
    11ee:	9f 92       	push	r9
    11f0:	af 92       	push	r10
    11f2:	bf 92       	push	r11
    11f4:	ef 92       	push	r14
    11f6:	ff 92       	push	r15
    11f8:	0f 93       	push	r16
    11fa:	1f 93       	push	r17
    11fc:	cf 93       	push	r28
    11fe:	df 93       	push	r29
    1200:	cd b7       	in	r28, 0x3d	; 61
    1202:	de b7       	in	r29, 0x3e	; 62
    1204:	a8 97       	sbiw	r28, 0x28	; 40
    1206:	0f b6       	in	r0, 0x3f	; 63
    1208:	f8 94       	cli
    120a:	de bf       	out	0x3e, r29	; 62
    120c:	0f be       	out	0x3f, r0	; 63
    120e:	cd bf       	out	0x3d, r28	; 61
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
    1210:	10 92 f2 00 	sts	0x00F2, r1	; 0x8000f2 <FatFs+0x1>
    1214:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <FatFs>
	if (!fs) return FR_OK;				/* Unregister fs object */
    1218:	00 97       	sbiw	r24, 0x00	; 0
    121a:	09 f4       	brne	.+2      	; 0x121e <pf_mount+0x3a>
    121c:	ca c0       	rjmp	.+404    	; 0x13b2 <pf_mount+0x1ce>
    121e:	7c 01       	movw	r14, r24

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
    1220:	0e 94 b8 04 	call	0x970	; 0x970 <disk_initialize>
    1224:	80 fd       	sbrc	r24, 0
    1226:	c7 c0       	rjmp	.+398    	; 0x13b6 <pf_mount+0x1d2>
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
    1228:	40 e0       	ldi	r20, 0x00	; 0
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	ba 01       	movw	r22, r20
    122e:	ce 01       	movw	r24, r28
    1230:	01 96       	adiw	r24, 0x01	; 1
    1232:	0e 94 0a 06 	call	0xc14	; 0xc14 <check_fs>
//   	sprintf(str,"%d",fmt);
//   	setpos(4,0);
//   	str_lcd(str);
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
    1236:	81 30       	cpi	r24, 0x01	; 1
    1238:	e1 f4       	brne	.+56     	; 0x1272 <pf_mount+0x8e>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
    123a:	00 e1       	ldi	r16, 0x10	; 16
    123c:	10 e0       	ldi	r17, 0x00	; 0
    123e:	2e eb       	ldi	r18, 0xBE	; 190
    1240:	31 e0       	ldi	r19, 0x01	; 1
    1242:	40 e0       	ldi	r20, 0x00	; 0
    1244:	50 e0       	ldi	r21, 0x00	; 0
    1246:	ba 01       	movw	r22, r20
    1248:	ce 01       	movw	r24, r28
    124a:	01 96       	adiw	r24, 0x01	; 1
    124c:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
    1250:	81 11       	cpse	r24, r1
    1252:	b3 c0       	rjmp	.+358    	; 0x13ba <pf_mount+0x1d6>
			fmt = 3;
		} else {
			if (buf[4]) {					/* Is the partition existing? */
    1254:	8d 81       	ldd	r24, Y+5	; 0x05
    1256:	88 23       	and	r24, r24
    1258:	09 f4       	brne	.+2      	; 0x125c <pf_mount+0x78>
    125a:	b1 c0       	rjmp	.+354    	; 0x13be <pf_mount+0x1da>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
    125c:	89 84       	ldd	r8, Y+9	; 0x09
    125e:	9a 84       	ldd	r9, Y+10	; 0x0a
    1260:	ab 84       	ldd	r10, Y+11	; 0x0b
    1262:	bc 84       	ldd	r11, Y+12	; 0x0c
				fmt = check_fs(buf, bsect);	/* Check the partition */
    1264:	b5 01       	movw	r22, r10
    1266:	a4 01       	movw	r20, r8
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	0e 94 0a 06 	call	0xc14	; 0xc14 <check_fs>
    1270:	03 c0       	rjmp	.+6      	; 0x1278 <pf_mount+0x94>

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
    1272:	81 2c       	mov	r8, r1
    1274:	91 2c       	mov	r9, r1
    1276:	54 01       	movw	r10, r8
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
				fmt = check_fs(buf, bsect);	/* Check the partition */
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    1278:	83 30       	cpi	r24, 0x03	; 3
    127a:	09 f4       	brne	.+2      	; 0x127e <pf_mount+0x9a>
    127c:	a2 c0       	rjmp	.+324    	; 0x13c2 <pf_mount+0x1de>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    127e:	81 11       	cpse	r24, r1
    1280:	a2 c0       	rjmp	.+324    	; 0x13c6 <pf_mount+0x1e2>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
    1282:	04 e2       	ldi	r16, 0x24	; 36
    1284:	10 e0       	ldi	r17, 0x00	; 0
    1286:	2d e0       	ldi	r18, 0x0D	; 13
    1288:	30 e0       	ldi	r19, 0x00	; 0
    128a:	b5 01       	movw	r22, r10
    128c:	a4 01       	movw	r20, r8
    128e:	ce 01       	movw	r24, r28
    1290:	01 96       	adiw	r24, 0x01	; 1
    1292:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
    1296:	81 11       	cpse	r24, r1
    1298:	98 c0       	rjmp	.+304    	; 0x13ca <pf_mount+0x1e6>

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
    129a:	2a 85       	ldd	r18, Y+10	; 0x0a
    129c:	3b 85       	ldd	r19, Y+11	; 0x0b
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
    12a2:	21 15       	cp	r18, r1
    12a4:	31 05       	cpc	r19, r1
    12a6:	41 05       	cpc	r20, r1
    12a8:	51 05       	cpc	r21, r1
    12aa:	21 f4       	brne	.+8      	; 0x12b4 <pf_mount+0xd0>
    12ac:	28 8d       	ldd	r18, Y+24	; 0x18
    12ae:	39 8d       	ldd	r19, Y+25	; 0x19
    12b0:	4a 8d       	ldd	r20, Y+26	; 0x1a
    12b2:	5b 8d       	ldd	r21, Y+27	; 0x1b

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
    12b4:	ac 81       	ldd	r26, Y+4	; 0x04
    12b6:	b0 e0       	ldi	r27, 0x00	; 0
    12b8:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <__muluhisi3>
    12bc:	6d a3       	std	Y+37, r22	; 0x25
    12be:	7e a3       	std	Y+38, r23	; 0x26
    12c0:	8f a3       	std	Y+39, r24	; 0x27
    12c2:	98 a7       	std	Y+40, r25	; 0x28
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
    12c4:	0a 81       	ldd	r16, Y+2	; 0x02
    12c6:	1b 81       	ldd	r17, Y+3	; 0x03
    12c8:	20 e0       	ldi	r18, 0x00	; 0
    12ca:	30 e0       	ldi	r19, 0x00	; 0
    12cc:	80 0e       	add	r8, r16
    12ce:	91 1e       	adc	r9, r17
    12d0:	a2 1e       	adc	r10, r18
    12d2:	b3 1e       	adc	r11, r19
    12d4:	d7 01       	movw	r26, r14
    12d6:	1c 96       	adiw	r26, 0x0c	; 12
    12d8:	8d 92       	st	X+, r8
    12da:	9d 92       	st	X+, r9
    12dc:	ad 92       	st	X+, r10
    12de:	bc 92       	st	X, r11
    12e0:	1f 97       	sbiw	r26, 0x0f	; 15
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
    12e2:	49 81       	ldd	r20, Y+1	; 0x01
    12e4:	11 96       	adiw	r26, 0x01	; 1
    12e6:	4c 93       	st	X, r20
    12e8:	11 97       	sbiw	r26, 0x01	; 1
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
    12ea:	4d 80       	ldd	r4, Y+5	; 0x05
    12ec:	5e 80       	ldd	r5, Y+6	; 0x06
    12ee:	15 96       	adiw	r26, 0x05	; 5
    12f0:	5c 92       	st	X, r5
    12f2:	4e 92       	st	-X, r4
    12f4:	14 97       	sbiw	r26, 0x04	; 4
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
    12f6:	8f 81       	ldd	r24, Y+7	; 0x07
    12f8:	98 85       	ldd	r25, Y+8	; 0x08
    12fa:	a0 e0       	ldi	r26, 0x00	; 0
    12fc:	b0 e0       	ldi	r27, 0x00	; 0
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
    12fe:	00 97       	sbiw	r24, 0x00	; 0
    1300:	a1 05       	cpc	r26, r1
    1302:	b1 05       	cpc	r27, r1
    1304:	21 f4       	brne	.+8      	; 0x130e <pf_mount+0x12a>
    1306:	8c 89       	ldd	r24, Y+20	; 0x14
    1308:	9d 89       	ldd	r25, Y+21	; 0x15
    130a:	ae 89       	ldd	r26, Y+22	; 0x16
    130c:	bf 89       	ldd	r27, Y+23	; 0x17
	mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
    130e:	56 94       	lsr	r5
    1310:	47 94       	ror	r4
    1312:	56 94       	lsr	r5
    1314:	47 94       	ror	r4
    1316:	56 94       	lsr	r5
    1318:	47 94       	ror	r4
    131a:	56 94       	lsr	r5
    131c:	47 94       	ror	r4
    131e:	61 2c       	mov	r6, r1
    1320:	71 2c       	mov	r7, r1
    1322:	80 1b       	sub	r24, r16
    1324:	91 0b       	sbc	r25, r17
    1326:	a2 0b       	sbc	r26, r18
    1328:	b3 0b       	sbc	r27, r19
    132a:	0d a1       	ldd	r16, Y+37	; 0x25
    132c:	1e a1       	ldd	r17, Y+38	; 0x26
    132e:	2f a1       	ldd	r18, Y+39	; 0x27
    1330:	38 a5       	ldd	r19, Y+40	; 0x28
    1332:	80 1b       	sub	r24, r16
    1334:	91 0b       	sbc	r25, r17
    1336:	a2 0b       	sbc	r26, r18
    1338:	b3 0b       	sbc	r27, r19
    133a:	bc 01       	movw	r22, r24
    133c:	cd 01       	movw	r24, r26
    133e:	64 19       	sub	r22, r4
    1340:	75 09       	sbc	r23, r5
    1342:	86 09       	sbc	r24, r6
    1344:	97 09       	sbc	r25, r7
		) / fs->csize + 2;
    1346:	24 2f       	mov	r18, r20
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <__udivmodsi4>
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
	mclst = (tsect						/* Last cluster# + 1 */
    1352:	ba 01       	movw	r22, r20
    1354:	a9 01       	movw	r20, r18
    1356:	4e 5f       	subi	r20, 0xFE	; 254
    1358:	5f 4f       	sbci	r21, 0xFF	; 255
    135a:	6f 4f       	sbci	r22, 0xFF	; 255
    135c:	7f 4f       	sbci	r23, 0xFF	; 255
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->max_clust = (CLUST)mclst;
    135e:	d7 01       	movw	r26, r14
    1360:	18 96       	adiw	r26, 0x08	; 8
    1362:	4d 93       	st	X+, r20
    1364:	5d 93       	st	X+, r21
    1366:	6d 93       	st	X+, r22
    1368:	7c 93       	st	X, r23
    136a:	1b 97       	sbiw	r26, 0x0b	; 11

	fmt = FS_FAT12;							/* Determine the FAT sub type */
	if (mclst >= 0xFF7) fmt = FS_FAT16;		/* Number of clusters >= 0xFF5 */
    136c:	47 3f       	cpi	r20, 0xF7	; 247
    136e:	bf e0       	ldi	r27, 0x0F	; 15
    1370:	5b 07       	cpc	r21, r27
    1372:	61 05       	cpc	r22, r1
    1374:	71 05       	cpc	r23, r1
    1376:	d0 f1       	brcs	.+116    	; 0x13ec <pf_mount+0x208>
    1378:	82 e0       	ldi	r24, 0x02	; 2
    137a:	39 c0       	rjmp	.+114    	; 0x13ee <pf_mount+0x20a>
    137c:	84 0c       	add	r8, r4
    137e:	95 1c       	adc	r9, r5
    1380:	a6 1c       	adc	r10, r6
    1382:	b7 1c       	adc	r11, r7
	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
#endif
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
    1384:	0d a1       	ldd	r16, Y+37	; 0x25
    1386:	1e a1       	ldd	r17, Y+38	; 0x26
    1388:	2f a1       	ldd	r18, Y+39	; 0x27
    138a:	38 a5       	ldd	r19, Y+40	; 0x28
    138c:	80 0e       	add	r8, r16
    138e:	91 1e       	adc	r9, r17
    1390:	a2 1e       	adc	r10, r18
    1392:	b3 1e       	adc	r11, r19
    1394:	d7 01       	movw	r26, r14
    1396:	54 96       	adiw	r26, 0x14	; 20
    1398:	8d 92       	st	X+, r8
    139a:	9d 92       	st	X+, r9
    139c:	ad 92       	st	X+, r10
    139e:	bc 92       	st	X, r11
    13a0:	57 97       	sbiw	r26, 0x17	; 23

	fs->flag = 0;
    13a2:	12 96       	adiw	r26, 0x02	; 2
    13a4:	1c 92       	st	X, r1
	FatFs = fs;
    13a6:	f0 92 f2 00 	sts	0x00F2, r15	; 0x8000f2 <FatFs+0x1>
    13aa:	e0 92 f1 00 	sts	0x00F1, r14	; 0x8000f1 <FatFs>

	return FR_OK;
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	30 c0       	rjmp	.+96     	; 0x1412 <pf_mount+0x22e>
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
	if (!fs) return FR_OK;				/* Unregister fs object */
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	2e c0       	rjmp	.+92     	; 0x1412 <pf_mount+0x22e>

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
		return FR_NOT_READY;
    13b6:	82 e0       	ldi	r24, 0x02	; 2
    13b8:	2c c0       	rjmp	.+88     	; 0x1412 <pf_mount+0x22e>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
				fmt = check_fs(buf, bsect);	/* Check the partition */
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	2a c0       	rjmp	.+84     	; 0x1412 <pf_mount+0x22e>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    13be:	87 e0       	ldi	r24, 0x07	; 7
    13c0:	28 c0       	rjmp	.+80     	; 0x1412 <pf_mount+0x22e>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
				fmt = check_fs(buf, bsect);	/* Check the partition */
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    13c2:	81 e0       	ldi	r24, 0x01	; 1
    13c4:	26 c0       	rjmp	.+76     	; 0x1412 <pf_mount+0x22e>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
    13c6:	87 e0       	ldi	r24, 0x07	; 7
    13c8:	24 c0       	rjmp	.+72     	; 0x1412 <pf_mount+0x22e>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	22 c0       	rjmp	.+68     	; 0x1412 <pf_mount+0x22e>
		fmt = FS_FAT32;
#else
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
    13ce:	f7 01       	movw	r30, r14
    13d0:	80 83       	st	Z, r24
#if _FS_FAT32
	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
#endif
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
    13d2:	8d a1       	ldd	r24, Y+37	; 0x25
    13d4:	9e a1       	ldd	r25, Y+38	; 0x26
    13d6:	af a1       	ldd	r26, Y+39	; 0x27
    13d8:	b8 a5       	ldd	r27, Y+40	; 0x28
    13da:	88 0d       	add	r24, r8
    13dc:	99 1d       	adc	r25, r9
    13de:	aa 1d       	adc	r26, r10
    13e0:	bb 1d       	adc	r27, r11
    13e2:	80 8b       	std	Z+16, r24	; 0x10
    13e4:	91 8b       	std	Z+17, r25	; 0x11
    13e6:	a2 8b       	std	Z+18, r26	; 0x12
    13e8:	b3 8b       	std	Z+19, r27	; 0x13
    13ea:	c8 cf       	rjmp	.-112    	; 0x137c <pf_mount+0x198>
	mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->max_clust = (CLUST)mclst;

	fmt = FS_FAT12;							/* Determine the FAT sub type */
    13ec:	81 e0       	ldi	r24, 0x01	; 1
	if (mclst >= 0xFF7) fmt = FS_FAT16;		/* Number of clusters >= 0xFF5 */
	if (mclst >= 0xFFF7)					/* Number of clusters >= 0xFFF5 */
    13ee:	47 3f       	cpi	r20, 0xF7	; 247
    13f0:	5f 4f       	sbci	r21, 0xFF	; 255
    13f2:	61 05       	cpc	r22, r1
    13f4:	71 05       	cpc	r23, r1
    13f6:	58 f3       	brcs	.-42     	; 0x13ce <pf_mount+0x1ea>
		fmt = FS_FAT32;
#else
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
    13f8:	83 e0       	ldi	r24, 0x03	; 3
    13fa:	d7 01       	movw	r26, r14
    13fc:	8c 93       	st	X, r24
#if _FS_FAT32
	if (fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
    13fe:	88 a1       	ldd	r24, Y+32	; 0x20
    1400:	99 a1       	ldd	r25, Y+33	; 0x21
    1402:	aa a1       	ldd	r26, Y+34	; 0x22
    1404:	bb a1       	ldd	r27, Y+35	; 0x23
    1406:	f7 01       	movw	r30, r14
    1408:	80 8b       	std	Z+16, r24	; 0x10
    140a:	91 8b       	std	Z+17, r25	; 0x11
    140c:	a2 8b       	std	Z+18, r26	; 0x12
    140e:	b3 8b       	std	Z+19, r27	; 0x13
    1410:	b5 cf       	rjmp	.-150    	; 0x137c <pf_mount+0x198>

	fs->flag = 0;
	FatFs = fs;

	return FR_OK;
}
    1412:	a8 96       	adiw	r28, 0x28	; 40
    1414:	0f b6       	in	r0, 0x3f	; 63
    1416:	f8 94       	cli
    1418:	de bf       	out	0x3e, r29	; 62
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	cd bf       	out	0x3d, r28	; 61
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	1f 91       	pop	r17
    1424:	0f 91       	pop	r16
    1426:	ff 90       	pop	r15
    1428:	ef 90       	pop	r14
    142a:	bf 90       	pop	r11
    142c:	af 90       	pop	r10
    142e:	9f 90       	pop	r9
    1430:	8f 90       	pop	r8
    1432:	7f 90       	pop	r7
    1434:	6f 90       	pop	r6
    1436:	5f 90       	pop	r5
    1438:	4f 90       	pop	r4
    143a:	08 95       	ret

0000143c <pf_open>:
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
    143c:	0f 93       	push	r16
    143e:	1f 93       	push	r17
    1440:	cf 93       	push	r28
    1442:	df 93       	push	r29
    1444:	cd b7       	in	r28, 0x3d	; 61
    1446:	de b7       	in	r29, 0x3e	; 62
    1448:	ec 97       	sbiw	r28, 0x3c	; 60
    144a:	0f b6       	in	r0, 0x3f	; 63
    144c:	f8 94       	cli
    144e:	de bf       	out	0x3e, r29	; 62
    1450:	0f be       	out	0x3f, r0	; 63
    1452:	cd bf       	out	0x3d, r28	; 61
	FRESULT res;
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
    1454:	00 91 f1 00 	lds	r16, 0x00F1	; 0x8000f1 <FatFs>
    1458:	10 91 f2 00 	lds	r17, 0x00F2	; 0x8000f2 <FatFs+0x1>


	if (!fs)						/* Check file system */
    145c:	01 15       	cp	r16, r1
    145e:	11 05       	cpc	r17, r1
    1460:	c9 f1       	breq	.+114    	; 0x14d4 <pf_open+0x98>
    1462:	bc 01       	movw	r22, r24
		return FR_NOT_ENABLED;

	fs->flag = 0;
    1464:	f8 01       	movw	r30, r16
    1466:	12 82       	std	Z+2, r1	; 0x02
	fs->buf = dir;
    1468:	ce 01       	movw	r24, r28
    146a:	4d 96       	adiw	r24, 0x1d	; 29
    146c:	97 83       	std	Z+7, r25	; 0x07
    146e:	86 83       	std	Z+6, r24	; 0x06
	dj.fn = sp;
    1470:	0c 97       	sbiw	r24, 0x0c	; 12
    1472:	9c 83       	std	Y+4, r25	; 0x04
    1474:	8b 83       	std	Y+3, r24	; 0x03
	res = follow_path(&dj, path);	/* Follow the file path */
    1476:	40 97       	sbiw	r24, 0x10	; 16
    1478:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <follow_path>
	if (res != FR_OK) return res;	/* Follow failed */
    147c:	81 11       	cpse	r24, r1
    147e:	2f c0       	rjmp	.+94     	; 0x14de <pf_open+0xa2>
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
    1480:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1482:	88 23       	and	r24, r24
    1484:	49 f1       	breq	.+82     	; 0x14d8 <pf_open+0x9c>
    1486:	88 a5       	ldd	r24, Y+40	; 0x28
    1488:	84 fd       	sbrc	r24, 4
    148a:	28 c0       	rjmp	.+80     	; 0x14dc <pf_open+0xa0>
		return FR_NO_FILE;

	fs->org_clust =						/* File start cluster */
#if _FS_FAT32
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
    148c:	89 a9       	ldd	r24, Y+49	; 0x31
    148e:	9a a9       	ldd	r25, Y+50	; 0x32
    1490:	a0 e0       	ldi	r26, 0x00	; 0
    1492:	b0 e0       	ldi	r27, 0x00	; 0
    1494:	dc 01       	movw	r26, r24
    1496:	99 27       	eor	r25, r25
    1498:	88 27       	eor	r24, r24
    149a:	4f a9       	ldd	r20, Y+55	; 0x37
    149c:	58 ad       	ldd	r21, Y+56	; 0x38
    149e:	60 e0       	ldi	r22, 0x00	; 0
    14a0:	70 e0       	ldi	r23, 0x00	; 0
    14a2:	84 2b       	or	r24, r20
    14a4:	95 2b       	or	r25, r21
    14a6:	a6 2b       	or	r26, r22
    14a8:	b7 2b       	or	r27, r23
	res = follow_path(&dj, path);	/* Follow the file path */
	if (res != FR_OK) return res;	/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
		return FR_NO_FILE;

	fs->org_clust =						/* File start cluster */
    14aa:	f8 01       	movw	r30, r16
    14ac:	80 a3       	std	Z+32, r24	; 0x20
    14ae:	91 a3       	std	Z+33, r25	; 0x21
    14b0:	a2 a3       	std	Z+34, r26	; 0x22
    14b2:	b3 a3       	std	Z+35, r27	; 0x23
#if _FS_FAT32
		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) |
#endif
		LD_WORD(dir+DIR_FstClusLO);
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    14b4:	89 ad       	ldd	r24, Y+57	; 0x39
    14b6:	9a ad       	ldd	r25, Y+58	; 0x3a
    14b8:	ab ad       	ldd	r26, Y+59	; 0x3b
    14ba:	bc ad       	ldd	r27, Y+60	; 0x3c
    14bc:	84 8f       	std	Z+28, r24	; 0x1c
    14be:	95 8f       	std	Z+29, r25	; 0x1d
    14c0:	a6 8f       	std	Z+30, r26	; 0x1e
    14c2:	b7 8f       	std	Z+31, r27	; 0x1f
	fs->fptr = 0;						/* File pointer */
    14c4:	10 8e       	std	Z+24, r1	; 0x18
    14c6:	11 8e       	std	Z+25, r1	; 0x19
    14c8:	12 8e       	std	Z+26, r1	; 0x1a
    14ca:	13 8e       	std	Z+27, r1	; 0x1b
	fs->flag = FA_OPENED;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	82 83       	std	Z+2, r24	; 0x02

	return FR_OK;
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	05 c0       	rjmp	.+10     	; 0x14de <pf_open+0xa2>
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;


	if (!fs)						/* Check file system */
		return FR_NOT_ENABLED;
    14d4:	86 e0       	ldi	r24, 0x06	; 6
    14d6:	03 c0       	rjmp	.+6      	; 0x14de <pf_open+0xa2>
	fs->buf = dir;
	dj.fn = sp;
	res = follow_path(&dj, path);	/* Follow the file path */
	if (res != FR_OK) return res;	/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
		return FR_NO_FILE;
    14d8:	83 e0       	ldi	r24, 0x03	; 3
    14da:	01 c0       	rjmp	.+2      	; 0x14de <pf_open+0xa2>
    14dc:	83 e0       	ldi	r24, 0x03	; 3
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
	fs->fptr = 0;						/* File pointer */
	fs->flag = FA_OPENED;

	return FR_OK;
}
    14de:	ec 96       	adiw	r28, 0x3c	; 60
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	de bf       	out	0x3e, r29	; 62
    14e6:	0f be       	out	0x3f, r0	; 63
    14e8:	cd bf       	out	0x3d, r28	; 61
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	1f 91       	pop	r17
    14f0:	0f 91       	pop	r16
    14f2:	08 95       	ret

000014f4 <pf_read>:
FRESULT pf_read (
	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
	WORD btr,		/* Number of bytes to read */
	WORD* br		/* Pointer to number of bytes read */
)
{
    14f4:	2f 92       	push	r2
    14f6:	3f 92       	push	r3
    14f8:	4f 92       	push	r4
    14fa:	5f 92       	push	r5
    14fc:	6f 92       	push	r6
    14fe:	7f 92       	push	r7
    1500:	8f 92       	push	r8
    1502:	9f 92       	push	r9
    1504:	af 92       	push	r10
    1506:	bf 92       	push	r11
    1508:	cf 92       	push	r12
    150a:	df 92       	push	r13
    150c:	ef 92       	push	r14
    150e:	ff 92       	push	r15
    1510:	0f 93       	push	r16
    1512:	1f 93       	push	r17
    1514:	cf 93       	push	r28
    1516:	df 93       	push	r29
    1518:	2c 01       	movw	r4, r24
    151a:	6b 01       	movw	r12, r22
    151c:	3a 01       	movw	r6, r20
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	BYTE *rbuff = buff;
	WORD rcnt;
	FATFS *fs = FatFs;
    151e:	c0 91 f1 00 	lds	r28, 0x00F1	; 0x8000f1 <FatFs>
    1522:	d0 91 f2 00 	lds	r29, 0x00F2	; 0x8000f2 <FatFs+0x1>


	*br = 0;
    1526:	fa 01       	movw	r30, r20
    1528:	11 82       	std	Z+1, r1	; 0x01
    152a:	10 82       	st	Z, r1
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    152c:	20 97       	sbiw	r28, 0x00	; 0
    152e:	09 f4       	brne	.+2      	; 0x1532 <pf_read+0x3e>
    1530:	b6 c0       	rjmp	.+364    	; 0x169e <pf_read+0x1aa>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    1532:	8a 81       	ldd	r24, Y+2	; 0x02
    1534:	80 ff       	sbrs	r24, 0
    1536:	b5 c0       	rjmp	.+362    	; 0x16a2 <pf_read+0x1ae>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
    1538:	8c 8d       	ldd	r24, Y+28	; 0x1c
    153a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    153c:	ae 8d       	ldd	r26, Y+30	; 0x1e
    153e:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1540:	48 8d       	ldd	r20, Y+24	; 0x18
    1542:	59 8d       	ldd	r21, Y+25	; 0x19
    1544:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1546:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1548:	84 1b       	sub	r24, r20
    154a:	95 0b       	sbc	r25, r21
    154c:	a6 0b       	sbc	r26, r22
    154e:	b7 0b       	sbc	r27, r23
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
    1550:	a6 01       	movw	r20, r12
    1552:	60 e0       	ldi	r22, 0x00	; 0
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	84 17       	cp	r24, r20
    1558:	95 07       	cpc	r25, r21
    155a:	a6 07       	cpc	r26, r22
    155c:	b7 07       	cpc	r27, r23
    155e:	08 f4       	brcc	.+2      	; 0x1562 <pf_read+0x6e>
    1560:	6c 01       	movw	r12, r24

	while (btr)	{									/* Repeat until all data transferred */
    1562:	c1 14       	cp	r12, r1
    1564:	d1 04       	cpc	r13, r1
    1566:	09 f4       	brne	.+2      	; 0x156a <pf_read+0x76>
    1568:	9e c0       	rjmp	.+316    	; 0x16a6 <pf_read+0x1b2>
    156a:	52 01       	movw	r10, r4
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
			if (!sect) goto fr_abort;
			fs->dsect = sect + fs->csect++;
		}
		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
    156c:	81 2c       	mov	r8, r1
    156e:	68 94       	set
    1570:	99 24       	eor	r9, r9
    1572:	91 f8       	bld	r9, 1
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
    1574:	31 2c       	mov	r3, r1
    1576:	21 2c       	mov	r2, r1

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
    1578:	e8 8c       	ldd	r14, Y+24	; 0x18
    157a:	f9 8c       	ldd	r15, Y+25	; 0x19
    157c:	0a 8d       	ldd	r16, Y+26	; 0x1a
    157e:	1b 8d       	ldd	r17, Y+27	; 0x1b
    1580:	d8 01       	movw	r26, r16
    1582:	c7 01       	movw	r24, r14
    1584:	91 70       	andi	r25, 0x01	; 1
    1586:	aa 27       	eor	r26, r26
    1588:	bb 27       	eor	r27, r27
    158a:	89 2b       	or	r24, r25
    158c:	8a 2b       	or	r24, r26
    158e:	8b 2b       	or	r24, r27
    1590:	09 f0       	breq	.+2      	; 0x1594 <pf_read+0xa0>
    1592:	49 c0       	rjmp	.+146    	; 0x1626 <pf_read+0x132>
			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
    1594:	29 81       	ldd	r18, Y+1	; 0x01
    1596:	30 e0       	ldi	r19, 0x00	; 0
    1598:	40 e0       	ldi	r20, 0x00	; 0
    159a:	50 e0       	ldi	r21, 0x00	; 0
    159c:	c8 01       	movw	r24, r16
    159e:	b7 01       	movw	r22, r14
    15a0:	05 2e       	mov	r0, r21
    15a2:	59 e0       	ldi	r21, 0x09	; 9
    15a4:	96 95       	lsr	r25
    15a6:	87 95       	ror	r24
    15a8:	77 95       	ror	r23
    15aa:	67 95       	ror	r22
    15ac:	5a 95       	dec	r21
    15ae:	d1 f7       	brne	.-12     	; 0x15a4 <pf_read+0xb0>
    15b0:	50 2d       	mov	r21, r0
    15b2:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <__udivmodsi4>
    15b6:	67 2b       	or	r22, r23
    15b8:	68 2b       	or	r22, r24
    15ba:	69 2b       	or	r22, r25
    15bc:	d1 f4       	brne	.+52     	; 0x15f2 <pf_read+0xfe>
				clst = (fs->fptr == 0) ?			/* On the top of the file? */
					fs->org_clust : get_fat(fs->curr_clust);
    15be:	ef 28       	or	r14, r15
    15c0:	e0 2a       	or	r14, r16
    15c2:	e1 2a       	or	r14, r17
    15c4:	29 f4       	brne	.+10     	; 0x15d0 <pf_read+0xdc>
    15c6:	68 a1       	ldd	r22, Y+32	; 0x20
    15c8:	79 a1       	ldd	r23, Y+33	; 0x21
    15ca:	8a a1       	ldd	r24, Y+34	; 0x22
    15cc:	9b a1       	ldd	r25, Y+35	; 0x23
    15ce:	06 c0       	rjmp	.+12     	; 0x15dc <pf_read+0xe8>
    15d0:	6c a1       	ldd	r22, Y+36	; 0x24
    15d2:	7d a1       	ldd	r23, Y+37	; 0x25
    15d4:	8e a1       	ldd	r24, Y+38	; 0x26
    15d6:	9f a1       	ldd	r25, Y+39	; 0x27
    15d8:	0e 94 53 06 	call	0xca6	; 0xca6 <get_fat>
				if (clst <= 1) goto fr_abort;
    15dc:	62 30       	cpi	r22, 0x02	; 2
    15de:	71 05       	cpc	r23, r1
    15e0:	81 05       	cpc	r24, r1
    15e2:	91 05       	cpc	r25, r1
    15e4:	08 f4       	brcc	.+2      	; 0x15e8 <pf_read+0xf4>
    15e6:	58 c0       	rjmp	.+176    	; 0x1698 <pf_read+0x1a4>
				fs->curr_clust = clst;				/* Update current cluster */
    15e8:	6c a3       	std	Y+36, r22	; 0x24
    15ea:	7d a3       	std	Y+37, r23	; 0x25
    15ec:	8e a3       	std	Y+38, r24	; 0x26
    15ee:	9f a3       	std	Y+39, r25	; 0x27
				fs->csect = 0;						/* Reset sector offset in the cluster */
    15f0:	1b 82       	std	Y+3, r1	; 0x03
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
    15f2:	6c a1       	ldd	r22, Y+36	; 0x24
    15f4:	7d a1       	ldd	r23, Y+37	; 0x25
    15f6:	8e a1       	ldd	r24, Y+38	; 0x26
    15f8:	9f a1       	ldd	r25, Y+39	; 0x27
    15fa:	0e 94 86 05 	call	0xb0c	; 0xb0c <clust2sect>
			if (!sect) goto fr_abort;
    15fe:	61 15       	cp	r22, r1
    1600:	71 05       	cpc	r23, r1
    1602:	81 05       	cpc	r24, r1
    1604:	91 05       	cpc	r25, r1
    1606:	09 f4       	brne	.+2      	; 0x160a <pf_read+0x116>
    1608:	47 c0       	rjmp	.+142    	; 0x1698 <pf_read+0x1a4>
			fs->dsect = sect + fs->csect++;
    160a:	2b 81       	ldd	r18, Y+3	; 0x03
    160c:	31 e0       	ldi	r19, 0x01	; 1
    160e:	32 0f       	add	r19, r18
    1610:	3b 83       	std	Y+3, r19	; 0x03
    1612:	dc 01       	movw	r26, r24
    1614:	cb 01       	movw	r24, r22
    1616:	82 0f       	add	r24, r18
    1618:	91 1d       	adc	r25, r1
    161a:	a1 1d       	adc	r26, r1
    161c:	b1 1d       	adc	r27, r1
    161e:	88 a7       	std	Y+40, r24	; 0x28
    1620:	99 a7       	std	Y+41, r25	; 0x29
    1622:	aa a7       	std	Y+42, r26	; 0x2a
    1624:	bb a7       	std	Y+43, r27	; 0x2b
		}
		rcnt = 512 - ((WORD)fs->fptr % 512);		/* Get partial sector data from sector buffer */
    1626:	28 8d       	ldd	r18, Y+24	; 0x18
    1628:	39 8d       	ldd	r19, Y+25	; 0x19
    162a:	31 70       	andi	r19, 0x01	; 1
    162c:	c4 01       	movw	r24, r8
    162e:	82 1b       	sub	r24, r18
    1630:	93 0b       	sbc	r25, r19
    1632:	76 01       	movw	r14, r12
    1634:	8c 15       	cp	r24, r12
    1636:	9d 05       	cpc	r25, r13
    1638:	08 f4       	brcc	.+2      	; 0x163c <pf_read+0x148>
    163a:	7c 01       	movw	r14, r24
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
    163c:	48 a5       	ldd	r20, Y+40	; 0x28
    163e:	59 a5       	ldd	r21, Y+41	; 0x29
    1640:	6a a5       	ldd	r22, Y+42	; 0x2a
    1642:	7b a5       	ldd	r23, Y+43	; 0x2b
    1644:	41 14       	cp	r4, r1
    1646:	51 04       	cpc	r5, r1
    1648:	19 f0       	breq	.+6      	; 0x1650 <pf_read+0x15c>
    164a:	8a 2d       	mov	r24, r10
    164c:	9b 2d       	mov	r25, r11
    164e:	02 c0       	rjmp	.+4      	; 0x1654 <pf_read+0x160>
    1650:	83 2d       	mov	r24, r3
    1652:	92 2d       	mov	r25, r2
    1654:	87 01       	movw	r16, r14
    1656:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <disk_readp>
		if (dr) goto fr_abort;
    165a:	81 11       	cpse	r24, r1
    165c:	1d c0       	rjmp	.+58     	; 0x1698 <pf_read+0x1a4>
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
    165e:	88 8d       	ldd	r24, Y+24	; 0x18
    1660:	99 8d       	ldd	r25, Y+25	; 0x19
    1662:	aa 8d       	ldd	r26, Y+26	; 0x1a
    1664:	bb 8d       	ldd	r27, Y+27	; 0x1b
    1666:	8e 0d       	add	r24, r14
    1668:	9f 1d       	adc	r25, r15
    166a:	a1 1d       	adc	r26, r1
    166c:	b1 1d       	adc	r27, r1
    166e:	88 8f       	std	Y+24, r24	; 0x18
    1670:	99 8f       	std	Y+25, r25	; 0x19
    1672:	aa 8f       	std	Y+26, r26	; 0x1a
    1674:	bb 8f       	std	Y+27, r27	; 0x1b
    1676:	ae 0c       	add	r10, r14
    1678:	bf 1c       	adc	r11, r15
		btr -= rcnt; *br += rcnt;
    167a:	ce 18       	sub	r12, r14
    167c:	df 08       	sbc	r13, r15
    167e:	f3 01       	movw	r30, r6
    1680:	80 81       	ld	r24, Z
    1682:	91 81       	ldd	r25, Z+1	; 0x01
    1684:	e8 0e       	add	r14, r24
    1686:	f9 1e       	adc	r15, r25
    1688:	f1 82       	std	Z+1, r15	; 0x01
    168a:	e0 82       	st	Z, r14
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
    168c:	c1 14       	cp	r12, r1
    168e:	d1 04       	cpc	r13, r1
    1690:	09 f0       	breq	.+2      	; 0x1694 <pf_read+0x1a0>
    1692:	72 cf       	rjmp	.-284    	; 0x1578 <pf_read+0x84>
		if (dr) goto fr_abort;
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
		btr -= rcnt; *br += rcnt;
	}

	return FR_OK;
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	08 c0       	rjmp	.+16     	; 0x16a8 <pf_read+0x1b4>

fr_abort:
	fs->flag = 0;
    1698:	1a 82       	std	Y+2, r1	; 0x02
	return FR_DISK_ERR;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	05 c0       	rjmp	.+10     	; 0x16a8 <pf_read+0x1b4>
	WORD rcnt;
	FATFS *fs = FatFs;


	*br = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    169e:	86 e0       	ldi	r24, 0x06	; 6
    16a0:	03 c0       	rjmp	.+6      	; 0x16a8 <pf_read+0x1b4>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;
    16a2:	85 e0       	ldi	r24, 0x05	; 5
    16a4:	01 c0       	rjmp	.+2      	; 0x16a8 <pf_read+0x1b4>
		if (dr) goto fr_abort;
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
		btr -= rcnt; *br += rcnt;
	}

	return FR_OK;
    16a6:	80 e0       	ldi	r24, 0x00	; 0

fr_abort:
	fs->flag = 0;
	return FR_DISK_ERR;
}
    16a8:	df 91       	pop	r29
    16aa:	cf 91       	pop	r28
    16ac:	1f 91       	pop	r17
    16ae:	0f 91       	pop	r16
    16b0:	ff 90       	pop	r15
    16b2:	ef 90       	pop	r14
    16b4:	df 90       	pop	r13
    16b6:	cf 90       	pop	r12
    16b8:	bf 90       	pop	r11
    16ba:	af 90       	pop	r10
    16bc:	9f 90       	pop	r9
    16be:	8f 90       	pop	r8
    16c0:	7f 90       	pop	r7
    16c2:	6f 90       	pop	r6
    16c4:	5f 90       	pop	r5
    16c6:	4f 90       	pop	r4
    16c8:	3f 90       	pop	r3
    16ca:	2f 90       	pop	r2
    16cc:	08 95       	ret

000016ce <pf_write>:
FRESULT pf_write (
	const void* buff,	/* Pointer to the data to be written */
	WORD btw,			/* Number of bytes to write (0:Finalize the current write operation) */
	WORD* bw			/* Pointer to number of bytes written */
)
{
    16ce:	4f 92       	push	r4
    16d0:	5f 92       	push	r5
    16d2:	6f 92       	push	r6
    16d4:	7f 92       	push	r7
    16d6:	8f 92       	push	r8
    16d8:	9f 92       	push	r9
    16da:	af 92       	push	r10
    16dc:	bf 92       	push	r11
    16de:	cf 92       	push	r12
    16e0:	df 92       	push	r13
    16e2:	ef 92       	push	r14
    16e4:	ff 92       	push	r15
    16e6:	0f 93       	push	r16
    16e8:	1f 93       	push	r17
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	6c 01       	movw	r12, r24
    16f0:	7b 01       	movw	r14, r22
    16f2:	5a 01       	movw	r10, r20
	CLUST clst;
	DWORD sect, remain;
	const BYTE *p = buff;
	WORD wcnt;
	FATFS *fs = FatFs;
    16f4:	c0 91 f1 00 	lds	r28, 0x00F1	; 0x8000f1 <FatFs>
    16f8:	d0 91 f2 00 	lds	r29, 0x00F2	; 0x8000f2 <FatFs+0x1>


	*bw = 0;
    16fc:	fa 01       	movw	r30, r20
    16fe:	11 82       	std	Z+1, r1	; 0x01
    1700:	10 82       	st	Z, r1
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1702:	20 97       	sbiw	r28, 0x00	; 0
    1704:	09 f4       	brne	.+2      	; 0x1708 <pf_write+0x3a>
    1706:	de c0       	rjmp	.+444    	; 0x18c4 <pf_write+0x1f6>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    1708:	8a 81       	ldd	r24, Y+2	; 0x02
    170a:	80 ff       	sbrs	r24, 0
    170c:	dd c0       	rjmp	.+442    	; 0x18c8 <pf_write+0x1fa>
		return FR_NOT_OPENED;

	if (!btw) {		/* Finalize request */
    170e:	67 2b       	or	r22, r23
    1710:	81 f4       	brne	.+32     	; 0x1732 <pf_write+0x64>
		if ((fs->flag & FA__WIP) && disk_writep(0, 0)) goto fw_abort;
    1712:	86 ff       	sbrs	r24, 6
    1714:	09 c0       	rjmp	.+18     	; 0x1728 <pf_write+0x5a>
    1716:	40 e0       	ldi	r20, 0x00	; 0
    1718:	50 e0       	ldi	r21, 0x00	; 0
    171a:	ba 01       	movw	r22, r20
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	0e 94 33 04 	call	0x866	; 0x866 <disk_writep>
    1724:	81 11       	cpse	r24, r1
    1726:	cb c0       	rjmp	.+406    	; 0x18be <pf_write+0x1f0>
		fs->flag &= ~FA__WIP;
    1728:	8a 81       	ldd	r24, Y+2	; 0x02
    172a:	8f 7b       	andi	r24, 0xBF	; 191
    172c:	8a 83       	std	Y+2, r24	; 0x02
		return FR_OK;
    172e:	80 e0       	ldi	r24, 0x00	; 0
    1730:	ce c0       	rjmp	.+412    	; 0x18ce <pf_write+0x200>
	} else {		/* Write data request */
		if (!(fs->flag & FA__WIP))		/* Round down fptr to the sector boundary */
    1732:	86 fd       	sbrc	r24, 6
    1734:	0a c0       	rjmp	.+20     	; 0x174a <pf_write+0x7c>
			fs->fptr &= 0xFFFFFE00;
    1736:	88 8d       	ldd	r24, Y+24	; 0x18
    1738:	99 8d       	ldd	r25, Y+25	; 0x19
    173a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    173c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    173e:	88 27       	eor	r24, r24
    1740:	9e 7f       	andi	r25, 0xFE	; 254
    1742:	88 8f       	std	Y+24, r24	; 0x18
    1744:	99 8f       	std	Y+25, r25	; 0x19
    1746:	aa 8f       	std	Y+26, r26	; 0x1a
    1748:	bb 8f       	std	Y+27, r27	; 0x1b
	}
	remain = fs->fsize - fs->fptr;
    174a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    174c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    174e:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1750:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1752:	48 8d       	ldd	r20, Y+24	; 0x18
    1754:	59 8d       	ldd	r21, Y+25	; 0x19
    1756:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1758:	7b 8d       	ldd	r23, Y+27	; 0x1b
    175a:	84 1b       	sub	r24, r20
    175c:	95 0b       	sbc	r25, r21
    175e:	a6 0b       	sbc	r26, r22
    1760:	b7 0b       	sbc	r27, r23
	if (btw > remain) btw = (WORD)remain;			/* Truncate btw by remaining bytes */
    1762:	a7 01       	movw	r20, r14
    1764:	60 e0       	ldi	r22, 0x00	; 0
    1766:	70 e0       	ldi	r23, 0x00	; 0
    1768:	84 17       	cp	r24, r20
    176a:	95 07       	cpc	r25, r21
    176c:	a6 07       	cpc	r26, r22
    176e:	b7 07       	cpc	r27, r23
    1770:	20 f4       	brcc	.+8      	; 0x177a <pf_write+0xac>
    1772:	7c 01       	movw	r14, r24

	while (btw)	{									/* Repeat until all data transferred */
    1774:	89 2b       	or	r24, r25
    1776:	09 f4       	brne	.+2      	; 0x177a <pf_write+0xac>
    1778:	a9 c0       	rjmp	.+338    	; 0x18cc <pf_write+0x1fe>
			if (!sect) goto fw_abort;
			fs->dsect = sect + fs->csect++;
			if (disk_writep(0, fs->dsect)) goto fw_abort;	/* Initiate a sector write operation */
			fs->flag |= FA__WIP;
		}
		wcnt = 512 - ((WORD)fs->fptr % 512);		/* Number of bytes to write to the sector */
    177a:	81 2c       	mov	r8, r1
    177c:	68 94       	set
    177e:	99 24       	eor	r9, r9
    1780:	91 f8       	bld	r9, 1
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain) btw = (WORD)remain;			/* Truncate btw by remaining bytes */

	while (btw)	{									/* Repeat until all data transferred */
		if (((WORD)fs->fptr % 512) == 0) {				/* On the sector boundary? */
    1782:	48 8c       	ldd	r4, Y+24	; 0x18
    1784:	59 8c       	ldd	r5, Y+25	; 0x19
    1786:	6a 8c       	ldd	r6, Y+26	; 0x1a
    1788:	7b 8c       	ldd	r7, Y+27	; 0x1b
    178a:	c2 01       	movw	r24, r4
    178c:	91 70       	andi	r25, 0x01	; 1
    178e:	89 2b       	or	r24, r25
    1790:	09 f0       	breq	.+2      	; 0x1794 <pf_write+0xc6>
    1792:	52 c0       	rjmp	.+164    	; 0x1838 <pf_write+0x16a>
			if ((fs->fptr / 512 % fs->csize) == 0) {	/* On the cluster boundary? */
    1794:	29 81       	ldd	r18, Y+1	; 0x01
    1796:	30 e0       	ldi	r19, 0x00	; 0
    1798:	40 e0       	ldi	r20, 0x00	; 0
    179a:	50 e0       	ldi	r21, 0x00	; 0
    179c:	c3 01       	movw	r24, r6
    179e:	b2 01       	movw	r22, r4
    17a0:	05 2e       	mov	r0, r21
    17a2:	59 e0       	ldi	r21, 0x09	; 9
    17a4:	96 95       	lsr	r25
    17a6:	87 95       	ror	r24
    17a8:	77 95       	ror	r23
    17aa:	67 95       	ror	r22
    17ac:	5a 95       	dec	r21
    17ae:	d1 f7       	brne	.-12     	; 0x17a4 <pf_write+0xd6>
    17b0:	50 2d       	mov	r21, r0
    17b2:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <__udivmodsi4>
    17b6:	67 2b       	or	r22, r23
    17b8:	68 2b       	or	r22, r24
    17ba:	69 2b       	or	r22, r25
    17bc:	d1 f4       	brne	.+52     	; 0x17f2 <pf_write+0x124>
				clst = (fs->fptr == 0) ?			/* On the top of the file? */
					fs->org_clust : get_fat(fs->curr_clust);
    17be:	45 28       	or	r4, r5
    17c0:	46 28       	or	r4, r6
    17c2:	47 28       	or	r4, r7
    17c4:	29 f4       	brne	.+10     	; 0x17d0 <pf_write+0x102>
    17c6:	68 a1       	ldd	r22, Y+32	; 0x20
    17c8:	79 a1       	ldd	r23, Y+33	; 0x21
    17ca:	8a a1       	ldd	r24, Y+34	; 0x22
    17cc:	9b a1       	ldd	r25, Y+35	; 0x23
    17ce:	06 c0       	rjmp	.+12     	; 0x17dc <pf_write+0x10e>
    17d0:	6c a1       	ldd	r22, Y+36	; 0x24
    17d2:	7d a1       	ldd	r23, Y+37	; 0x25
    17d4:	8e a1       	ldd	r24, Y+38	; 0x26
    17d6:	9f a1       	ldd	r25, Y+39	; 0x27
    17d8:	0e 94 53 06 	call	0xca6	; 0xca6 <get_fat>
				if (clst <= 1) goto fw_abort;
    17dc:	62 30       	cpi	r22, 0x02	; 2
    17de:	71 05       	cpc	r23, r1
    17e0:	81 05       	cpc	r24, r1
    17e2:	91 05       	cpc	r25, r1
    17e4:	08 f4       	brcc	.+2      	; 0x17e8 <pf_write+0x11a>
    17e6:	6b c0       	rjmp	.+214    	; 0x18be <pf_write+0x1f0>
				fs->curr_clust = clst;				/* Update current cluster */
    17e8:	6c a3       	std	Y+36, r22	; 0x24
    17ea:	7d a3       	std	Y+37, r23	; 0x25
    17ec:	8e a3       	std	Y+38, r24	; 0x26
    17ee:	9f a3       	std	Y+39, r25	; 0x27
				fs->csect = 0;						/* Reset sector offset in the cluster */
    17f0:	1b 82       	std	Y+3, r1	; 0x03
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
    17f2:	6c a1       	ldd	r22, Y+36	; 0x24
    17f4:	7d a1       	ldd	r23, Y+37	; 0x25
    17f6:	8e a1       	ldd	r24, Y+38	; 0x26
    17f8:	9f a1       	ldd	r25, Y+39	; 0x27
    17fa:	0e 94 86 05 	call	0xb0c	; 0xb0c <clust2sect>
			if (!sect) goto fw_abort;
    17fe:	61 15       	cp	r22, r1
    1800:	71 05       	cpc	r23, r1
    1802:	81 05       	cpc	r24, r1
    1804:	91 05       	cpc	r25, r1
    1806:	09 f4       	brne	.+2      	; 0x180a <pf_write+0x13c>
    1808:	5a c0       	rjmp	.+180    	; 0x18be <pf_write+0x1f0>
			fs->dsect = sect + fs->csect++;
    180a:	2b 81       	ldd	r18, Y+3	; 0x03
    180c:	31 e0       	ldi	r19, 0x01	; 1
    180e:	32 0f       	add	r19, r18
    1810:	3b 83       	std	Y+3, r19	; 0x03
    1812:	ab 01       	movw	r20, r22
    1814:	bc 01       	movw	r22, r24
    1816:	42 0f       	add	r20, r18
    1818:	51 1d       	adc	r21, r1
    181a:	61 1d       	adc	r22, r1
    181c:	71 1d       	adc	r23, r1
    181e:	48 a7       	std	Y+40, r20	; 0x28
    1820:	59 a7       	std	Y+41, r21	; 0x29
    1822:	6a a7       	std	Y+42, r22	; 0x2a
    1824:	7b a7       	std	Y+43, r23	; 0x2b
			if (disk_writep(0, fs->dsect)) goto fw_abort;	/* Initiate a sector write operation */
    1826:	80 e0       	ldi	r24, 0x00	; 0
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	0e 94 33 04 	call	0x866	; 0x866 <disk_writep>
    182e:	81 11       	cpse	r24, r1
    1830:	46 c0       	rjmp	.+140    	; 0x18be <pf_write+0x1f0>
			fs->flag |= FA__WIP;
    1832:	8a 81       	ldd	r24, Y+2	; 0x02
    1834:	80 64       	ori	r24, 0x40	; 64
    1836:	8a 83       	std	Y+2, r24	; 0x02
		}
		wcnt = 512 - ((WORD)fs->fptr % 512);		/* Number of bytes to write to the sector */
    1838:	88 8d       	ldd	r24, Y+24	; 0x18
    183a:	99 8d       	ldd	r25, Y+25	; 0x19
    183c:	91 70       	andi	r25, 0x01	; 1
    183e:	94 01       	movw	r18, r8
    1840:	28 1b       	sub	r18, r24
    1842:	39 0b       	sbc	r19, r25
    1844:	87 01       	movw	r16, r14
    1846:	2e 15       	cp	r18, r14
    1848:	3f 05       	cpc	r19, r15
    184a:	08 f4       	brcc	.+2      	; 0x184e <pf_write+0x180>
    184c:	89 01       	movw	r16, r18
		if (wcnt > btw) wcnt = btw;
		if (disk_writep(p, wcnt)) goto fw_abort;	/* Send data to the sector */
    184e:	28 01       	movw	r4, r16
    1850:	61 2c       	mov	r6, r1
    1852:	71 2c       	mov	r7, r1
    1854:	b3 01       	movw	r22, r6
    1856:	a2 01       	movw	r20, r4
    1858:	c6 01       	movw	r24, r12
    185a:	0e 94 33 04 	call	0x866	; 0x866 <disk_writep>
    185e:	81 11       	cpse	r24, r1
    1860:	2e c0       	rjmp	.+92     	; 0x18be <pf_write+0x1f0>
		fs->fptr += wcnt; p += wcnt;				/* Update pointers and counters */
    1862:	88 8d       	ldd	r24, Y+24	; 0x18
    1864:	99 8d       	ldd	r25, Y+25	; 0x19
    1866:	aa 8d       	ldd	r26, Y+26	; 0x1a
    1868:	bb 8d       	ldd	r27, Y+27	; 0x1b
    186a:	48 0e       	add	r4, r24
    186c:	59 1e       	adc	r5, r25
    186e:	6a 1e       	adc	r6, r26
    1870:	7b 1e       	adc	r7, r27
    1872:	48 8e       	std	Y+24, r4	; 0x18
    1874:	59 8e       	std	Y+25, r5	; 0x19
    1876:	6a 8e       	std	Y+26, r6	; 0x1a
    1878:	7b 8e       	std	Y+27, r7	; 0x1b
    187a:	c0 0e       	add	r12, r16
    187c:	d1 1e       	adc	r13, r17
		btw -= wcnt; *bw += wcnt;
    187e:	e0 1a       	sub	r14, r16
    1880:	f1 0a       	sbc	r15, r17
    1882:	f5 01       	movw	r30, r10
    1884:	80 81       	ld	r24, Z
    1886:	91 81       	ldd	r25, Z+1	; 0x01
    1888:	08 0f       	add	r16, r24
    188a:	19 1f       	adc	r17, r25
    188c:	11 83       	std	Z+1, r17	; 0x01
    188e:	00 83       	st	Z, r16
		if (((WORD)fs->fptr % 512) == 0) {
    1890:	88 8d       	ldd	r24, Y+24	; 0x18
    1892:	99 8d       	ldd	r25, Y+25	; 0x19
    1894:	91 70       	andi	r25, 0x01	; 1
    1896:	89 2b       	or	r24, r25
    1898:	61 f4       	brne	.+24     	; 0x18b2 <pf_write+0x1e4>
			if (disk_writep(0, 0)) goto fw_abort;	/* Finalize the currtent secter write operation */
    189a:	40 e0       	ldi	r20, 0x00	; 0
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	ba 01       	movw	r22, r20
    18a0:	80 e0       	ldi	r24, 0x00	; 0
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 33 04 	call	0x866	; 0x866 <disk_writep>
    18a8:	81 11       	cpse	r24, r1
    18aa:	09 c0       	rjmp	.+18     	; 0x18be <pf_write+0x1f0>
			fs->flag &= ~FA__WIP;
    18ac:	8a 81       	ldd	r24, Y+2	; 0x02
    18ae:	8f 7b       	andi	r24, 0xBF	; 191
    18b0:	8a 83       	std	Y+2, r24	; 0x02
			fs->fptr &= 0xFFFFFE00;
	}
	remain = fs->fsize - fs->fptr;
	if (btw > remain) btw = (WORD)remain;			/* Truncate btw by remaining bytes */

	while (btw)	{									/* Repeat until all data transferred */
    18b2:	e1 14       	cp	r14, r1
    18b4:	f1 04       	cpc	r15, r1
    18b6:	09 f0       	breq	.+2      	; 0x18ba <pf_write+0x1ec>
    18b8:	64 cf       	rjmp	.-312    	; 0x1782 <pf_write+0xb4>
			if (disk_writep(0, 0)) goto fw_abort;	/* Finalize the currtent secter write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    18ba:	80 e0       	ldi	r24, 0x00	; 0
    18bc:	08 c0       	rjmp	.+16     	; 0x18ce <pf_write+0x200>

fw_abort:
	fs->flag = 0;
    18be:	1a 82       	std	Y+2, r1	; 0x02
	return FR_DISK_ERR;
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	05 c0       	rjmp	.+10     	; 0x18ce <pf_write+0x200>
	WORD wcnt;
	FATFS *fs = FatFs;


	*bw = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    18c4:	86 e0       	ldi	r24, 0x06	; 6
    18c6:	03 c0       	rjmp	.+6      	; 0x18ce <pf_write+0x200>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;
    18c8:	85 e0       	ldi	r24, 0x05	; 5
    18ca:	01 c0       	rjmp	.+2      	; 0x18ce <pf_write+0x200>
			if (disk_writep(0, 0)) goto fw_abort;	/* Finalize the currtent secter write operation */
			fs->flag &= ~FA__WIP;
		}
	}

	return FR_OK;
    18cc:	80 e0       	ldi	r24, 0x00	; 0

fw_abort:
	fs->flag = 0;
	return FR_DISK_ERR;
}
    18ce:	df 91       	pop	r29
    18d0:	cf 91       	pop	r28
    18d2:	1f 91       	pop	r17
    18d4:	0f 91       	pop	r16
    18d6:	ff 90       	pop	r15
    18d8:	ef 90       	pop	r14
    18da:	df 90       	pop	r13
    18dc:	cf 90       	pop	r12
    18de:	bf 90       	pop	r11
    18e0:	af 90       	pop	r10
    18e2:	9f 90       	pop	r9
    18e4:	8f 90       	pop	r8
    18e6:	7f 90       	pop	r7
    18e8:	6f 90       	pop	r6
    18ea:	5f 90       	pop	r5
    18ec:	4f 90       	pop	r4
    18ee:	08 95       	ret

000018f0 <pf_lseek>:
#if _USE_LSEEK

FRESULT pf_lseek (
	DWORD ofs		/* File pointer from top of file */
)
{
    18f0:	4f 92       	push	r4
    18f2:	5f 92       	push	r5
    18f4:	6f 92       	push	r6
    18f6:	7f 92       	push	r7
    18f8:	8f 92       	push	r8
    18fa:	9f 92       	push	r9
    18fc:	af 92       	push	r10
    18fe:	bf 92       	push	r11
    1900:	cf 92       	push	r12
    1902:	df 92       	push	r13
    1904:	ef 92       	push	r14
    1906:	ff 92       	push	r15
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	cf 93       	push	r28
    190e:	df 93       	push	r29
    1910:	00 d0       	rcall	.+0      	; 0x1912 <pf_lseek+0x22>
    1912:	00 d0       	rcall	.+0      	; 0x1914 <pf_lseek+0x24>
    1914:	cd b7       	in	r28, 0x3d	; 61
    1916:	de b7       	in	r29, 0x3e	; 62
	CLUST clst;
	DWORD bcs, sect, ifptr;
	FATFS *fs = FatFs;
    1918:	00 91 f1 00 	lds	r16, 0x00F1	; 0x8000f1 <FatFs>
    191c:	10 91 f2 00 	lds	r17, 0x00F2	; 0x8000f2 <FatFs+0x1>


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1920:	01 15       	cp	r16, r1
    1922:	11 05       	cpc	r17, r1
    1924:	09 f4       	brne	.+2      	; 0x1928 <pf_lseek+0x38>
    1926:	f6 c0       	rjmp	.+492    	; 0x1b14 <pf_lseek+0x224>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
    1928:	d8 01       	movw	r26, r16
    192a:	12 96       	adiw	r26, 0x02	; 2
    192c:	2c 91       	ld	r18, X
    192e:	12 97       	sbiw	r26, 0x02	; 2
    1930:	20 ff       	sbrs	r18, 0
    1932:	f2 c0       	rjmp	.+484    	; 0x1b18 <pf_lseek+0x228>
			return FR_NOT_OPENED;

	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
    1934:	5c 96       	adiw	r26, 0x1c	; 28
    1936:	8d 90       	ld	r8, X+
    1938:	9d 90       	ld	r9, X+
    193a:	ad 90       	ld	r10, X+
    193c:	bc 90       	ld	r11, X
    193e:	5f 97       	sbiw	r26, 0x1f	; 31
    1940:	c6 2e       	mov	r12, r22
    1942:	d7 2e       	mov	r13, r23
    1944:	e8 2e       	mov	r14, r24
    1946:	f9 2e       	mov	r15, r25
    1948:	8c 14       	cp	r8, r12
    194a:	9d 04       	cpc	r9, r13
    194c:	ae 04       	cpc	r10, r14
    194e:	bf 04       	cpc	r11, r15
    1950:	10 f4       	brcc	.+4      	; 0x1956 <pf_lseek+0x66>
    1952:	75 01       	movw	r14, r10
    1954:	64 01       	movw	r12, r8
	ifptr = fs->fptr;
    1956:	f8 01       	movw	r30, r16
    1958:	40 8c       	ldd	r4, Z+24	; 0x18
    195a:	51 8c       	ldd	r5, Z+25	; 0x19
    195c:	62 8c       	ldd	r6, Z+26	; 0x1a
    195e:	73 8c       	ldd	r7, Z+27	; 0x1b
	fs->fptr = 0;
    1960:	10 8e       	std	Z+24, r1	; 0x18
    1962:	11 8e       	std	Z+25, r1	; 0x19
    1964:	12 8e       	std	Z+26, r1	; 0x1a
    1966:	13 8e       	std	Z+27, r1	; 0x1b
	if (ofs > 0) {
    1968:	c1 14       	cp	r12, r1
    196a:	d1 04       	cpc	r13, r1
    196c:	e1 04       	cpc	r14, r1
    196e:	f1 04       	cpc	r15, r1
    1970:	09 f4       	brne	.+2      	; 0x1974 <pf_lseek+0x84>
    1972:	d4 c0       	rjmp	.+424    	; 0x1b1c <pf_lseek+0x22c>
		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
    1974:	81 80       	ldd	r8, Z+1	; 0x01
    1976:	91 2c       	mov	r9, r1
    1978:	a1 2c       	mov	r10, r1
    197a:	b1 2c       	mov	r11, r1
    197c:	07 2e       	mov	r0, r23
    197e:	79 e0       	ldi	r23, 0x09	; 9
    1980:	88 0c       	add	r8, r8
    1982:	99 1c       	adc	r9, r9
    1984:	aa 1c       	adc	r10, r10
    1986:	bb 1c       	adc	r11, r11
    1988:	7a 95       	dec	r23
    198a:	d1 f7       	brne	.-12     	; 0x1980 <pf_lseek+0x90>
    198c:	70 2d       	mov	r23, r0
		if (ifptr > 0 &&
    198e:	41 14       	cp	r4, r1
    1990:	51 04       	cpc	r5, r1
    1992:	61 04       	cpc	r6, r1
    1994:	71 04       	cpc	r7, r1
    1996:	09 f4       	brne	.+2      	; 0x199a <pf_lseek+0xaa>
    1998:	3f c0       	rjmp	.+126    	; 0x1a18 <pf_lseek+0x128>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    199a:	b1 e0       	ldi	r27, 0x01	; 1
    199c:	4b 1a       	sub	r4, r27
    199e:	51 08       	sbc	r5, r1
    19a0:	61 08       	sbc	r6, r1
    19a2:	71 08       	sbc	r7, r1
    19a4:	c7 01       	movw	r24, r14
    19a6:	b6 01       	movw	r22, r12
    19a8:	61 50       	subi	r22, 0x01	; 1
    19aa:	71 09       	sbc	r23, r1
    19ac:	81 09       	sbc	r24, r1
    19ae:	91 09       	sbc	r25, r1
    19b0:	a5 01       	movw	r20, r10
    19b2:	94 01       	movw	r18, r8
    19b4:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <__udivmodsi4>
    19b8:	29 83       	std	Y+1, r18	; 0x01
    19ba:	3a 83       	std	Y+2, r19	; 0x02
    19bc:	4b 83       	std	Y+3, r20	; 0x03
    19be:	5c 83       	std	Y+4, r21	; 0x04
    19c0:	c3 01       	movw	r24, r6
    19c2:	b2 01       	movw	r22, r4
    19c4:	a5 01       	movw	r20, r10
    19c6:	94 01       	movw	r18, r8
    19c8:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <__udivmodsi4>
	if (ofs > fs->fsize) ofs = fs->fsize;	/* Clip offset with the file size */
	ifptr = fs->fptr;
	fs->fptr = 0;
	if (ofs > 0) {
		bcs = (DWORD)fs->csize * 512;	/* Cluster size (byte) */
		if (ifptr > 0 &&
    19cc:	89 81       	ldd	r24, Y+1	; 0x01
    19ce:	9a 81       	ldd	r25, Y+2	; 0x02
    19d0:	ab 81       	ldd	r26, Y+3	; 0x03
    19d2:	bc 81       	ldd	r27, Y+4	; 0x04
    19d4:	82 17       	cp	r24, r18
    19d6:	93 07       	cpc	r25, r19
    19d8:	a4 07       	cpc	r26, r20
    19da:	b5 07       	cpc	r27, r21
    19dc:	e8 f0       	brcs	.+58     	; 0x1a18 <pf_lseek+0x128>
			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
			fs->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    19de:	88 27       	eor	r24, r24
    19e0:	99 27       	eor	r25, r25
    19e2:	dc 01       	movw	r26, r24
    19e4:	88 19       	sub	r24, r8
    19e6:	99 09       	sbc	r25, r9
    19e8:	aa 09       	sbc	r26, r10
    19ea:	bb 09       	sbc	r27, r11
    19ec:	48 22       	and	r4, r24
    19ee:	59 22       	and	r5, r25
    19f0:	6a 22       	and	r6, r26
    19f2:	7b 22       	and	r7, r27
    19f4:	d8 01       	movw	r26, r16
    19f6:	58 96       	adiw	r26, 0x18	; 24
    19f8:	4d 92       	st	X+, r4
    19fa:	5d 92       	st	X+, r5
    19fc:	6d 92       	st	X+, r6
    19fe:	7c 92       	st	X, r7
    1a00:	5b 97       	sbiw	r26, 0x1b	; 27
			ofs -= fs->fptr;
    1a02:	c4 18       	sub	r12, r4
    1a04:	d5 08       	sbc	r13, r5
    1a06:	e6 08       	sbc	r14, r6
    1a08:	f7 08       	sbc	r15, r7
			clst = fs->curr_clust;
    1a0a:	94 96       	adiw	r26, 0x24	; 36
    1a0c:	6d 91       	ld	r22, X+
    1a0e:	7d 91       	ld	r23, X+
    1a10:	8d 91       	ld	r24, X+
    1a12:	9c 91       	ld	r25, X
    1a14:	97 97       	sbiw	r26, 0x27	; 39
    1a16:	09 c0       	rjmp	.+18     	; 0x1a2a <pf_lseek+0x13a>
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
    1a18:	f8 01       	movw	r30, r16
    1a1a:	60 a1       	ldd	r22, Z+32	; 0x20
    1a1c:	71 a1       	ldd	r23, Z+33	; 0x21
    1a1e:	82 a1       	ldd	r24, Z+34	; 0x22
    1a20:	93 a1       	ldd	r25, Z+35	; 0x23
			fs->curr_clust = clst;
    1a22:	64 a3       	std	Z+36, r22	; 0x24
    1a24:	75 a3       	std	Z+37, r23	; 0x25
    1a26:	86 a3       	std	Z+38, r24	; 0x26
    1a28:	97 a3       	std	Z+39, r25	; 0x27
		}
		while (ofs > bcs) {				/* Cluster following loop */
    1a2a:	8c 14       	cp	r8, r12
    1a2c:	9d 04       	cpc	r9, r13
    1a2e:	ae 04       	cpc	r10, r14
    1a30:	bf 04       	cpc	r11, r15
    1a32:	60 f5       	brcc	.+88     	; 0x1a8c <pf_lseek+0x19c>
			clst = get_fat(clst);		/* Follow cluster chain */
    1a34:	0e 94 53 06 	call	0xca6	; 0xca6 <get_fat>
			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
    1a38:	62 30       	cpi	r22, 0x02	; 2
    1a3a:	71 05       	cpc	r23, r1
    1a3c:	81 05       	cpc	r24, r1
    1a3e:	91 05       	cpc	r25, r1
    1a40:	08 f4       	brcc	.+2      	; 0x1a44 <pf_lseek+0x154>
    1a42:	63 c0       	rjmp	.+198    	; 0x1b0a <pf_lseek+0x21a>
    1a44:	f8 01       	movw	r30, r16
    1a46:	40 84       	ldd	r4, Z+8	; 0x08
    1a48:	51 84       	ldd	r5, Z+9	; 0x09
    1a4a:	62 84       	ldd	r6, Z+10	; 0x0a
    1a4c:	73 84       	ldd	r7, Z+11	; 0x0b
    1a4e:	64 15       	cp	r22, r4
    1a50:	75 05       	cpc	r23, r5
    1a52:	86 05       	cpc	r24, r6
    1a54:	97 05       	cpc	r25, r7
    1a56:	08 f0       	brcs	.+2      	; 0x1a5a <pf_lseek+0x16a>
    1a58:	58 c0       	rjmp	.+176    	; 0x1b0a <pf_lseek+0x21a>
			fs->curr_clust = clst;
    1a5a:	64 a3       	std	Z+36, r22	; 0x24
    1a5c:	75 a3       	std	Z+37, r23	; 0x25
    1a5e:	86 a3       	std	Z+38, r24	; 0x26
    1a60:	97 a3       	std	Z+39, r25	; 0x27
			fs->fptr += bcs;
    1a62:	40 8c       	ldd	r4, Z+24	; 0x18
    1a64:	51 8c       	ldd	r5, Z+25	; 0x19
    1a66:	62 8c       	ldd	r6, Z+26	; 0x1a
    1a68:	73 8c       	ldd	r7, Z+27	; 0x1b
    1a6a:	48 0c       	add	r4, r8
    1a6c:	59 1c       	adc	r5, r9
    1a6e:	6a 1c       	adc	r6, r10
    1a70:	7b 1c       	adc	r7, r11
    1a72:	40 8e       	std	Z+24, r4	; 0x18
    1a74:	51 8e       	std	Z+25, r5	; 0x19
    1a76:	62 8e       	std	Z+26, r6	; 0x1a
    1a78:	73 8e       	std	Z+27, r7	; 0x1b
			ofs -= bcs;
    1a7a:	c8 18       	sub	r12, r8
    1a7c:	d9 08       	sbc	r13, r9
    1a7e:	ea 08       	sbc	r14, r10
    1a80:	fb 08       	sbc	r15, r11
			clst = fs->curr_clust;
		} else {							/* When seek to back cluster, */
			clst = fs->org_clust;			/* start from the first cluster */
			fs->curr_clust = clst;
		}
		while (ofs > bcs) {				/* Cluster following loop */
    1a82:	8c 14       	cp	r8, r12
    1a84:	9d 04       	cpc	r9, r13
    1a86:	ae 04       	cpc	r10, r14
    1a88:	bf 04       	cpc	r11, r15
    1a8a:	a0 f2       	brcs	.-88     	; 0x1a34 <pf_lseek+0x144>
			if (clst <= 1 || clst >= fs->max_clust) goto fe_abort;
			fs->curr_clust = clst;
			fs->fptr += bcs;
			ofs -= bcs;
		}
		fs->fptr += ofs;
    1a8c:	d8 01       	movw	r26, r16
    1a8e:	58 96       	adiw	r26, 0x18	; 24
    1a90:	8d 90       	ld	r8, X+
    1a92:	9d 90       	ld	r9, X+
    1a94:	ad 90       	ld	r10, X+
    1a96:	bc 90       	ld	r11, X
    1a98:	5b 97       	sbiw	r26, 0x1b	; 27
    1a9a:	8c 0c       	add	r8, r12
    1a9c:	9d 1c       	adc	r9, r13
    1a9e:	ae 1c       	adc	r10, r14
    1aa0:	bf 1c       	adc	r11, r15
    1aa2:	f8 01       	movw	r30, r16
    1aa4:	80 8e       	std	Z+24, r8	; 0x18
    1aa6:	91 8e       	std	Z+25, r9	; 0x19
    1aa8:	a2 8e       	std	Z+26, r10	; 0x1a
    1aaa:	b3 8e       	std	Z+27, r11	; 0x1b
		sect = clust2sect(clst);		/* Current sector */
    1aac:	0e 94 86 05 	call	0xb0c	; 0xb0c <clust2sect>
		if (!sect) goto fe_abort;
    1ab0:	61 15       	cp	r22, r1
    1ab2:	71 05       	cpc	r23, r1
    1ab4:	81 05       	cpc	r24, r1
    1ab6:	91 05       	cpc	r25, r1
    1ab8:	41 f1       	breq	.+80     	; 0x1b0a <pf_lseek+0x21a>
		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
    1aba:	46 01       	movw	r8, r12
    1abc:	57 01       	movw	r10, r14
    1abe:	07 2e       	mov	r0, r23
    1ac0:	79 e0       	ldi	r23, 0x09	; 9
    1ac2:	b6 94       	lsr	r11
    1ac4:	a7 94       	ror	r10
    1ac6:	97 94       	ror	r9
    1ac8:	87 94       	ror	r8
    1aca:	7a 95       	dec	r23
    1acc:	d1 f7       	brne	.-12     	; 0x1ac2 <pf_lseek+0x1d2>
    1ace:	70 2d       	mov	r23, r0
		if (ofs % 512)
    1ad0:	f1 e0       	ldi	r31, 0x01	; 1
    1ad2:	df 22       	and	r13, r31
    1ad4:	ee 24       	eor	r14, r14
    1ad6:	ff 24       	eor	r15, r15
    1ad8:	cd 28       	or	r12, r13
    1ada:	ce 28       	or	r12, r14
    1adc:	cf 28       	or	r12, r15
    1ade:	29 f4       	brne	.+10     	; 0x1aea <pf_lseek+0x1fa>
			ofs -= bcs;
		}
		fs->fptr += ofs;
		sect = clust2sect(clst);		/* Current sector */
		if (!sect) goto fe_abort;
		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
    1ae0:	d8 01       	movw	r26, r16
    1ae2:	13 96       	adiw	r26, 0x03	; 3
    1ae4:	8c 92       	st	X, r8
		if (ofs % 512)
			fs->dsect = sect + fs->csect++;
	}

	return FR_OK;
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
    1ae8:	1a c0       	rjmp	.+52     	; 0x1b1e <pf_lseek+0x22e>
		fs->fptr += ofs;
		sect = clust2sect(clst);		/* Current sector */
		if (!sect) goto fe_abort;
		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
		if (ofs % 512)
			fs->dsect = sect + fs->csect++;
    1aea:	21 e0       	ldi	r18, 0x01	; 1
    1aec:	28 0d       	add	r18, r8
    1aee:	f8 01       	movw	r30, r16
    1af0:	23 83       	std	Z+3, r18	; 0x03
    1af2:	dc 01       	movw	r26, r24
    1af4:	cb 01       	movw	r24, r22
    1af6:	88 0d       	add	r24, r8
    1af8:	91 1d       	adc	r25, r1
    1afa:	a1 1d       	adc	r26, r1
    1afc:	b1 1d       	adc	r27, r1
    1afe:	80 a7       	std	Z+40, r24	; 0x28
    1b00:	91 a7       	std	Z+41, r25	; 0x29
    1b02:	a2 a7       	std	Z+42, r26	; 0x2a
    1b04:	b3 a7       	std	Z+43, r27	; 0x2b
	}

	return FR_OK;
    1b06:	80 e0       	ldi	r24, 0x00	; 0
    1b08:	0a c0       	rjmp	.+20     	; 0x1b1e <pf_lseek+0x22e>

fe_abort:
	fs->flag = 0;
    1b0a:	d8 01       	movw	r26, r16
    1b0c:	12 96       	adiw	r26, 0x02	; 2
    1b0e:	1c 92       	st	X, r1
	return FR_DISK_ERR;
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	05 c0       	rjmp	.+10     	; 0x1b1e <pf_lseek+0x22e>
	CLUST clst;
	DWORD bcs, sect, ifptr;
	FATFS *fs = FatFs;


	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
    1b14:	86 e0       	ldi	r24, 0x06	; 6
    1b16:	03 c0       	rjmp	.+6      	; 0x1b1e <pf_lseek+0x22e>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
			return FR_NOT_OPENED;
    1b18:	85 e0       	ldi	r24, 0x05	; 5
    1b1a:	01 c0       	rjmp	.+2      	; 0x1b1e <pf_lseek+0x22e>
		fs->csect = (BYTE)(ofs / 512);	/* Sector offset in the cluster */
		if (ofs % 512)
			fs->dsect = sect + fs->csect++;
	}

	return FR_OK;
    1b1c:	80 e0       	ldi	r24, 0x00	; 0

fe_abort:
	fs->flag = 0;
	return FR_DISK_ERR;
}
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	0f 90       	pop	r0
    1b24:	0f 90       	pop	r0
    1b26:	df 91       	pop	r29
    1b28:	cf 91       	pop	r28
    1b2a:	1f 91       	pop	r17
    1b2c:	0f 91       	pop	r16
    1b2e:	ff 90       	pop	r15
    1b30:	ef 90       	pop	r14
    1b32:	df 90       	pop	r13
    1b34:	cf 90       	pop	r12
    1b36:	bf 90       	pop	r11
    1b38:	af 90       	pop	r10
    1b3a:	9f 90       	pop	r9
    1b3c:	8f 90       	pop	r8
    1b3e:	7f 90       	pop	r7
    1b40:	6f 90       	pop	r6
    1b42:	5f 90       	pop	r5
    1b44:	4f 90       	pop	r4
    1b46:	08 95       	ret

00001b48 <port_ini>:
#include "SPI.h"

void port_ini(void)
{

	PORTD=0x00;
    1b48:	12 ba       	out	0x12, r1	; 18
	DDRD=0xFF;
    1b4a:	8f ef       	ldi	r24, 0xFF	; 255
    1b4c:	81 bb       	out	0x11, r24	; 17
	PORTB|=(1<<SS)|(1<<MISO)|(1<<MOSI);
    1b4e:	88 b3       	in	r24, 0x18	; 24
    1b50:	80 67       	ori	r24, 0x70	; 112
    1b52:	88 bb       	out	0x18, r24	; 24
	DDRB|=(1<<SS)|(1<<MOSI)|(1<<SCK);
    1b54:	87 b3       	in	r24, 0x17	; 23
    1b56:	80 6b       	ori	r24, 0xB0	; 176
    1b58:	87 bb       	out	0x17, r24	; 23
    1b5a:	08 95       	ret

00001b5c <__udivmodsi4>:
    1b5c:	a1 e2       	ldi	r26, 0x21	; 33
    1b5e:	1a 2e       	mov	r1, r26
    1b60:	aa 1b       	sub	r26, r26
    1b62:	bb 1b       	sub	r27, r27
    1b64:	fd 01       	movw	r30, r26
    1b66:	0d c0       	rjmp	.+26     	; 0x1b82 <__udivmodsi4_ep>

00001b68 <__udivmodsi4_loop>:
    1b68:	aa 1f       	adc	r26, r26
    1b6a:	bb 1f       	adc	r27, r27
    1b6c:	ee 1f       	adc	r30, r30
    1b6e:	ff 1f       	adc	r31, r31
    1b70:	a2 17       	cp	r26, r18
    1b72:	b3 07       	cpc	r27, r19
    1b74:	e4 07       	cpc	r30, r20
    1b76:	f5 07       	cpc	r31, r21
    1b78:	20 f0       	brcs	.+8      	; 0x1b82 <__udivmodsi4_ep>
    1b7a:	a2 1b       	sub	r26, r18
    1b7c:	b3 0b       	sbc	r27, r19
    1b7e:	e4 0b       	sbc	r30, r20
    1b80:	f5 0b       	sbc	r31, r21

00001b82 <__udivmodsi4_ep>:
    1b82:	66 1f       	adc	r22, r22
    1b84:	77 1f       	adc	r23, r23
    1b86:	88 1f       	adc	r24, r24
    1b88:	99 1f       	adc	r25, r25
    1b8a:	1a 94       	dec	r1
    1b8c:	69 f7       	brne	.-38     	; 0x1b68 <__udivmodsi4_loop>
    1b8e:	60 95       	com	r22
    1b90:	70 95       	com	r23
    1b92:	80 95       	com	r24
    1b94:	90 95       	com	r25
    1b96:	9b 01       	movw	r18, r22
    1b98:	ac 01       	movw	r20, r24
    1b9a:	bd 01       	movw	r22, r26
    1b9c:	cf 01       	movw	r24, r30
    1b9e:	08 95       	ret

00001ba0 <__muluhisi3>:
    1ba0:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__umulhisi3>
    1ba4:	a5 9f       	mul	r26, r21
    1ba6:	90 0d       	add	r25, r0
    1ba8:	b4 9f       	mul	r27, r20
    1baa:	90 0d       	add	r25, r0
    1bac:	a4 9f       	mul	r26, r20
    1bae:	80 0d       	add	r24, r0
    1bb0:	91 1d       	adc	r25, r1
    1bb2:	11 24       	eor	r1, r1
    1bb4:	08 95       	ret

00001bb6 <__umulhisi3>:
    1bb6:	a2 9f       	mul	r26, r18
    1bb8:	b0 01       	movw	r22, r0
    1bba:	b3 9f       	mul	r27, r19
    1bbc:	c0 01       	movw	r24, r0
    1bbe:	a3 9f       	mul	r26, r19
    1bc0:	70 0d       	add	r23, r0
    1bc2:	81 1d       	adc	r24, r1
    1bc4:	11 24       	eor	r1, r1
    1bc6:	91 1d       	adc	r25, r1
    1bc8:	b2 9f       	mul	r27, r18
    1bca:	70 0d       	add	r23, r0
    1bcc:	81 1d       	adc	r24, r1
    1bce:	11 24       	eor	r1, r1
    1bd0:	91 1d       	adc	r25, r1
    1bd2:	08 95       	ret

00001bd4 <_exit>:
    1bd4:	f8 94       	cli

00001bd6 <__stop_program>:
    1bd6:	ff cf       	rjmp	.-2      	; 0x1bd6 <__stop_program>
